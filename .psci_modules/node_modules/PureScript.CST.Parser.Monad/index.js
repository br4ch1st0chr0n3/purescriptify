"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Lazy = require("../Data.Lazy/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var PureScript_CST_Errors = require("../PureScript.CST.Errors/index.js");
var PureScript_CST_TokenStream = require("../PureScript.CST.TokenStream/index.js");
var More = (function () {
    function More(value0) {
        this.value0 = value0;
    };
    More.create = function (value0) {
        return new More(value0);
    };
    return More;
})();
var Done = (function () {
    function Done(value0) {
        this.value0 = value0;
    };
    Done.create = function (value0) {
        return new Done(value0);
    };
    return Done;
})();
var ParseFail = (function () {
    function ParseFail(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ParseFail.create = function (value0) {
        return function (value1) {
            return new ParseFail(value0, value1);
        };
    };
    return ParseFail;
})();
var ParseSucc = (function () {
    function ParseSucc(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ParseSucc.create = function (value0) {
        return function (value1) {
            return new ParseSucc(value0, value1);
        };
    };
    return ParseSucc;
})();
var Parser = function (x) {
    return x;
};
var lazyParser = {
    defer: function (k) {
        var parser = Data_Lazy.defer(k);
        return function (state, more, resume, done) {
            var v = Data_Lazy.force(parser);
            return v(state, more, resume, done);
        };
    }
};
var functorParser = {
    map: function (f) {
        return function (v) {
            return function (state1, more, resume, done) {
                return v(state1, more, resume, function (state2, a) {
                    return done(state2, f(a));
                });
            };
        };
    }
};
var applyParser = {
    apply: function (v) {
        return function (v1) {
            return function (state1, more, resume, done) {
                return v(state1, more, resume, function (state2, f) {
                    return more(function (v2) {
                        return v1(state2, more, resume, function (state3, a) {
                            return done(state3, f(a));
                        });
                    });
                });
            };
        };
    },
    Functor0: function () {
        return functorParser;
    }
};
var bindParser = {
    bind: function (v) {
        return function (k) {
            return function (state1, more, resume, done) {
                return v(state1, more, resume, function (state2, a) {
                    return more(function (v1) {
                        var v2 = k(a);
                        return v2(state2, more, resume, done);
                    });
                });
            };
        };
    },
    Apply0: function () {
        return applyParser;
    }
};
var applicativeParser = {
    pure: function (a) {
        return function (state1, v, v1, done) {
            return done(state1, a);
        };
    },
    Apply0: function () {
        return applyParser;
    }
};
var monadParser = {
    Applicative0: function () {
        return applicativeParser;
    },
    Bind1: function () {
        return bindParser;
    }
};
var altParser = {
    alt: function (v) {
        return function (v1) {
            return function (state1, more, resume, done) {
                var state2 = (function () {
                    if (state1.consumed) {
                        return {
                            consumed: false,
                            errors: state1.errors,
                            stream: state1.stream
                        };
                    };
                    return state1;
                })();
                return v(state2, more, function (state3, error) {
                    if (state3.consumed) {
                        return resume(state3, error);
                    };
                    return v1(state1, more, resume, done);
                }, done);
            };
        };
    },
    Functor0: function () {
        return functorParser;
    }
};
var $$try = function (v) {
    return function (state1, more, resume, done) {
        return v(state1, more, function (state2, error) {
            return resume({
                consumed: state1.consumed,
                errors: state2.errors,
                stream: state2.stream
            }, error);
        }, done);
    };
};
var take = function (k) {
    return function (state, v, resume, done) {
        var v1 = PureScript_CST_TokenStream.step(state.stream);
        if (v1 instanceof PureScript_CST_TokenStream.TokenError) {
            return resume(state, {
                error: v1.value1,
                position: v1.value0
            });
        };
        if (v1 instanceof PureScript_CST_TokenStream.TokenEOF) {
            return resume(state, {
                error: PureScript_CST_Errors.UnexpectedEof.value,
                position: v1.value0
            });
        };
        if (v1 instanceof PureScript_CST_TokenStream.TokenCons) {
            var v2 = k(v1.value0);
            if (v2 instanceof Data_Either.Left) {
                return resume(state, {
                    error: v2.value0,
                    position: v1.value0.range.start
                });
            };
            if (v2 instanceof Data_Either.Right) {
                return done({
                    consumed: true,
                    stream: v1.value2,
                    errors: state.errors
                }, v2.value0);
            };
            throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 172, column 11 - line 182, column 18): " + [ v2.constructor.name ]);
        };
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 166, column 7 - line 182, column 18): " + [ v1.constructor.name ]);
    };
};
var runParser$prime = function (state1) {
    return function (v) {
        var run = function ($copy_v1) {
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v1) {
                if (v1 instanceof More) {
                    $copy_v1 = v1.value0(Data_Unit.unit);
                    return;
                };
                if (v1 instanceof Done) {
                    $tco_done = true;
                    return v1.value0;
                };
                throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 241, column 9 - line 243, column 16): " + [ v1.constructor.name ]);
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($copy_v1);
            };
            return $tco_result;
        };
        return run(v(state1, More.create, function (state2, error) {
            return new Done(new ParseFail(error, state2));
        }, function (state2, value) {
            return new Done(new ParseSucc(value, state2));
        }));
    };
};
var recover = function (k) {
    return function (v) {
        return function (state1, more, resume, done) {
            return v({
                consumed: false,
                errors: state1.errors,
                stream: state1.stream
            }, more, function (state2, error) {
                var v1 = k(error)(state1.stream);
                if (v1 instanceof Data_Maybe.Nothing) {
                    return resume({
                        consumed: state1.consumed,
                        errors: state2.errors,
                        stream: state2.stream
                    }, error);
                };
                if (v1 instanceof Data_Maybe.Just) {
                    return done({
                        consumed: true,
                        errors: Data_Array.snoc(state2.errors)(error),
                        stream: v1.value0.value1
                    }, v1.value0.value0);
                };
                throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 149, column 13 - line 158, column 20): " + [ v1.constructor.name ]);
            }, done);
        };
    };
};
var optional = function (p) {
    return Control_Alt.alt(altParser)(Data_Functor.map(functorParser)(Data_Maybe.Just.create)(p))(Control_Applicative.pure(applicativeParser)(Data_Maybe.Nothing.value));
};
var many = function (v) {
    return function (state1, more, resume, done) {
        var go = function (acc, state2) {
            var state2$prime = (function () {
                if (state2.consumed) {
                    return {
                        consumed: false,
                        errors: state2.errors,
                        stream: state2.stream
                    };
                };
                return state2;
            })();
            return v(state2$prime, more, function (state3, error) {
                if (state3.consumed) {
                    return resume(state3, error);
                };
                return done(state3, Data_Array.reverse(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(acc)));
            }, function (state3, value) {
                return go(new Data_List_Types.Cons(value, acc), state3);
            });
        };
        return go(Data_List_Types.Nil.value, state1);
    };
};
var lookAhead = function (v) {
    return function (state1, more, resume, done) {
        return v(state1, more, function (v1, error) {
            return resume(state1, error);
        }, function (v1, value) {
            return done(state1, value);
        });
    };
};
var initialParserState = function (stream) {
    return {
        consumed: false,
        errors: [  ],
        stream: stream
    };
};
var fromParserResult = function (v) {
    if (v instanceof ParseFail) {
        return new Data_Either.Left(v.value0);
    };
    if (v instanceof ParseSucc) {
        return new Data_Either.Right(new Data_Tuple.Tuple(v.value0, v.value1.errors));
    };
    throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 253, column 20 - line 257, column 29): " + [ v.constructor.name ]);
};
var runParser = function (stream) {
    var $104 = runParser$prime(initialParserState(stream));
    return function ($105) {
        return fromParserResult($104($105));
    };
};
var fail = function (error) {
    return function (state, v, resume, v1) {
        return resume(state, error);
    };
};
var eof = function (state, v, resume, done) {
    var v1 = PureScript_CST_TokenStream.step(state.stream);
    if (v1 instanceof PureScript_CST_TokenStream.TokenError) {
        return resume(state, {
            error: v1.value1,
            position: v1.value0
        });
    };
    if (v1 instanceof PureScript_CST_TokenStream.TokenEOF) {
        return done({
            consumed: true,
            stream: state.stream,
            errors: state.errors
        }, new Data_Tuple.Tuple(v1.value0, v1.value1));
    };
    if (v1 instanceof PureScript_CST_TokenStream.TokenCons) {
        return resume(state, {
            error: new PureScript_CST_Errors.ExpectedEof(v1.value0.value),
            position: v1.value0.range.start
        });
    };
    throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 188, column 7 - line 197, column 14): " + [ v1.constructor.name ]);
};
module.exports = {
    ParseFail: ParseFail,
    ParseSucc: ParseSucc,
    initialParserState: initialParserState,
    fromParserResult: fromParserResult,
    runParser: runParser,
    "runParser'": runParser$prime,
    take: take,
    fail: fail,
    "try": $$try,
    lookAhead: lookAhead,
    many: many,
    optional: optional,
    eof: eof,
    recover: recover,
    functorParser: functorParser,
    applyParser: applyParser,
    applicativeParser: applicativeParser,
    bindParser: bindParser,
    monadParser: monadParser,
    altParser: altParser,
    lazyParser: lazyParser
};
