"use strict";
var Control_Category = require("../Control.Category/index.js");
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Symbol = require("../Data.Symbol/index.js");
var Effect_Uncurried = require("../Effect.Uncurried/index.js");
var Record = require("../Record/index.js");
var Type_Data_RowList = require("../Type.Data.RowList/index.js");

// | Encapsulates a safe event operation. `EventFn`s can be composed
// | to perform multiple operations.
// |
// | For example:
// |
// | ```purs
// | input { onChange: handler (preventDefault >>> targetValue)
// |                     \value -> setState \_ -> { value }
// |       }
// | ```
var EventFn = function (x) {
    return x;
};

// | Unsafely create an `EventFn`. This function should be avoided as it can allow
// | a `SyntheticEvent` to escape its scope. Accessing a React event's properties is only
// | valid in a synchronous event callback.
// |
// | Instead, use the helper functions specific to your platform, such as `React.Basic.DOM.Events`.
var unsafeEventFn = EventFn;
var semigroupoidBuilder = Control_Semigroupoid.semigroupoidFn;
var mergeNil = {
    mergeImpl: function (v) {
        return function (v1) {
            return function (v2) {
                return {};
            };
        };
    }
};
var mergeImpl = function (dict) {
    return dict.mergeImpl;
};
var mergeCons = function (dictIsSymbol) {
    return function () {
        return function () {
            return function () {
                return function () {
                    return function (dictMerge) {
                        return {
                            mergeImpl: function (v) {
                                return function (fns) {
                                    return function (a) {
                                        var v1 = mergeImpl(dictMerge)(Type_Data_RowList.RLProxy.value)(Record["delete"](dictIsSymbol)()()(Data_Symbol.SProxy.value)(fns));
                                        var v2 = Record.get(dictIsSymbol)()(Data_Symbol.SProxy.value)(fns);
                                        return Record.insert(dictIsSymbol)()()(Data_Symbol.SProxy.value)(v2(a))(v1(a));
                                    };
                                };
                            }
                        };
                    };
                };
            };
        };
    };
};

// | Merge multiple `EventFn` operations and collect their results.
// |
// | For example:
// |
// | ```purs
// | input { onChange: handler (merge { targetValue, timeStamp })
// |                     \{ targetValue, timeStamp } -> setState \_ -> { ... }
// |       }
// | ```
var merge = function () {
    return function (dictMerge) {
        return mergeImpl(dictMerge)(Type_Data_RowList.RLProxy.value);
    };
};

// | Create an `EventHandler` which discards the `SyntheticEvent`.
// |
// | For example:
// |
// | ```purs
// | input { onChange: handler_ (setState \_ -> { value })
// |       }
// | ```
var handler_ = function ($17) {
    return Effect_Uncurried.mkEffectFn1(Data_Function["const"]($17));
};

// | Create an `EventHandler`, given an `EventFn` and a callback.
// |
// | For example:
// |
// | ```purs
// | input { onChange: handler targetValue
// |                     \value -> setState \_ -> { value }
// |       }
// | ```
var handler = function (v) {
    return function (cb) {
        return function ($18) {
            return cb(v($18))();
        };
    };
};
var categoryBuilder = Control_Category.categoryFn;
var syntheticEvent = Control_Category.identity(categoryBuilder);
module.exports = {
    unsafeEventFn: unsafeEventFn,
    handler: handler,
    handler_: handler_,
    syntheticEvent: syntheticEvent,
    merge: merge,
    mergeImpl: mergeImpl,
    semigroupoidBuilder: semigroupoidBuilder,
    categoryBuilder: categoryBuilder,
    mergeNil: mergeNil,
    mergeCons: mergeCons
};
