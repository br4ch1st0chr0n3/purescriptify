"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Show_Generic = require("../Data.Show.Generic/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_String_NonEmpty_CodeUnits = require("../Data.String.NonEmpty.CodeUnits/index.js");
var Data_String_NonEmpty_Internal = require("../Data.String.NonEmpty.Internal/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var JSURI = require("../JSURI/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");
var URI_Common = require("../URI.Common/index.js");
var URI_Query = require("../URI.Query/index.js");

// | The default `Value` type used for `QueryPairs`.
var Value = function (x) {
    return x;
};

// | A query string split into an array of key/value pairs. There is no precise
// | spec for this, but the format is commonly used, so this attempts to handle
// | these strings in a sensible way.
// |
// | - The representation uses an array rather than a map, so duplicate keys
// |   are supported.
// | - Keys are not required to have a value associated.
// | - `&` and `;` are both treated as pair delimiters.
var QueryPairs = function (x) {
    return x;
};

// | The default `Key` type used for `QueryPairs`.
var Key = function (x) {
    return x;
};

// | Returns the string value for a value, percent-decoding any characters
// | that require it.
// |
// | ``` purescript
// | valueToString (unsafeValueFromString "foo") = "foo"
// | valueToString (unsafeValueFromString "foo%23bar") = "foo#bar"
// | ```
var valueToString = function (v) {
    return Data_Maybe.fromJust()(JSURI["decodeURIComponent"](v));
};

// | Returns the string value for a value without percent-decoding. Only
// | "unsafe" in the sense that values this produces may need further decoding,
// | the name is more for symmetry with the `fromString`/`unsafeFromString`
// | pairing.
var unsafeValueToString = function (v) {
    return v;
};

// | Constructs a value from a string directly - no percent-encoding
// | will be applied. This is useful when using a custom encoding scheme for
// | the value, to prevent double-encoding.
var unsafeValueFromString = Value;

// | Returns the string value for a key without percent-decoding. Only
// | "unsafe" in the sense that values this produces may need further decoding,
// | the name is more for symmetry with the `fromString`/`unsafeFromString`
// | pairing.
var unsafeKeyToString = function (v) {
    return v;
};

// | Constructs a key value from a string directly - no percent-encoding
// | will be applied. This is useful when using a custom encoding scheme for
// | the key, to prevent double-encoding.
var unsafeKeyFromString = Key;
var showValue = {
    show: function (v) {
        return "(QueryPairs.unsafeValueFromString " + (Data_Show.show(Data_Show.showString)(v) + ")");
    }
};
var showKey = {
    show: function (v) {
        return "(QueryPairs.unsafeKeyFromString " + (Data_Show.show(Data_Show.showString)(v) + ")");
    }
};
var semigroupValue = Data_Semigroup.semigroupString;
var semigroupQueryPairs = Data_Semigroup.semigroupArray;
var semigroupKey = Data_Semigroup.semigroupString;

// | A printer for key/value pairs style query string.
// |
// | As a counterpart to the `parser` this function also requires the `Key`
// | and `Value` components to be printed back from their custom representations.
// | If no custom types are being used, pass `identity` for both of these arguments.
var print = function (printK) {
    return function (printV) {
        return function (v) {
            var printPart = function (v1) {
                if (v1.value1 instanceof Data_Maybe.Nothing) {
                    return unsafeKeyToString(printK(v1.value0));
                };
                if (v1.value1 instanceof Data_Maybe.Just) {
                    return unsafeKeyToString(printK(v1.value0)) + ("=" + unsafeValueToString(printV(v1.value1.value0)));
                };
                throw new Error("Failed pattern match at URI.Extra.QueryPairs (line 102, column 17 - line 106, column 78): " + [ v1.constructor.name ]);
            };
            return URI_Query.unsafeFromString(Data_String_Common.joinWith("&")(Data_Array.fromFoldable(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(printPart)(v))));
        };
    };
};
var ordValue = Data_Ord.ordString;
var ordQueryPairs = function (dictOrd) {
    return function (dictOrd1) {
        return Data_Ord.ordArray(Data_Tuple.ordTuple(dictOrd)(Data_Maybe.ordMaybe(dictOrd1)));
    };
};
var ordKey = Data_Ord.ordString;
var monoidValue = Data_Monoid.monoidString;
var monoidQueryPairs = Data_Monoid.monoidArray;
var monoidKey = Data_Monoid.monoidString;

// | Returns the string value for a key, percent-decoding any characters
// | that require it.
// |
// | ``` purescript
// | keyToString (unsafeKeyFromString "foo") = "foo"
// | keyToString (unsafeKeyFromString "foo%23bar") = "foo#bar"
// | ```
var keyToString = function (v) {
    return Data_Maybe.fromJust()(JSURI["decodeURIComponent"](v));
};

// | The supported key characters, excluding percent-encodings.
var keyPartChar = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(URI_Common.unreserved)(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "!", "$", "'", "(", ")", "*", "+", ",", ":", "@", "/", "?" ]));

// | Constructs a value from a string, percent-encoding any characters
// | that require it. Note that running this on a string that has already had
// | percent-encoding applied will double-encode it, for those situations use
// | `unsafeValueFromString` instead.
// |
// | ``` purescript
// | valueFromString "foo" = unsafeValueFromString "foo"
// | valueFromString "foo#bar" = unsafeValueFromString "foo%23bar"
// | valueFromString "foo%23bar" = unsafeValueFromString "foo%2523bar"
// | ```
var valueFromString = (function () {
    var $37 = URI_Common.printEncoded(keyPartChar);
    return function ($38) {
        return Value($37($38));
    };
})();

// | The supported value characters, excluding percent-encodings.
var valuePartChar = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(keyPartChar)(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("="));
var parsePart = function (parseK) {
    return function (parseV) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(URI_Common.wrapParser(Data_Identity.monadIdentity)(function ($39) {
            return parseK(Key($39));
        })(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_String_NonEmpty_Internal.joinWith(Data_Foldable.foldableArray)(""))(Data_Array.some(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_String_NonEmpty_CodeUnits.singleton)(keyPartChar))(URI_Common.pctEncoded)))))(function (key) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(URI_Common.wrapParser(Data_Identity.monadIdentity)(Data_Traversable.traverse(Data_Traversable.traversableMaybe)(Data_Either.applicativeEither)(function ($40) {
                return parseV(Value($40));
            }))(Text_Parsing_Parser_Combinators.optionMaybe(Data_Identity.monadIdentity)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("="))(function () {
                return Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_String_NonEmpty_Internal.joinWith(Data_Foldable.foldableArray)(""))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_String_NonEmpty_CodeUnits.singleton)(valuePartChar))(URI_Common.pctEncoded)));
            }))))(function (value) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Data_Tuple.Tuple(key, value));
            });
        });
    };
};

// | Parses a query into key/value pairs.
// |
// | This function allows for the `Key` and `Value` components to be parsed
// | into custom representations. If this is not necessary, use `pure` for both
// | these arguments.
var parse = function (parseK) {
    return function (parseV) {
        var $41 = Data_Bifunctor.bimap(Data_Bifunctor.bifunctorEither)(function (v) {
            return v.value0;
        })(QueryPairs);
        var $42 = Data_Function.flip(Text_Parsing_Parser.runParser)(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Array.fromFoldable(Data_List_Types.foldableList))(Text_Parsing_Parser_Combinators.sepBy(Data_Identity.monadIdentity)(parsePart(parseK)(parseV))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("&"))));
        return function ($43) {
            return $41($42(URI_Query.unsafeToString($43)));
        };
    };
};

// | Constructs a key value from a string, percent-encoding any characters
// | that require it. Note that running this on a string that has already had
// | percent-encoding applied will double-encode it, for those situations use
// | `unsafeKeyFromString` instead.
// |
// | ``` purescript
// | keyFromString "foo" = unsafeKeyFromString "foo"
// | keyFromString "foo#bar" = unsafeKeyFromString "foo%23bar"
// | keyFromString "foo%23bar" = unsafeKeyFromString "foo%2523bar"
// | ```
var keyFromString = (function () {
    var $44 = URI_Common.printEncoded(keyPartChar);
    return function ($45) {
        return Key($44($45));
    };
})();
var genericQueryPairs = {
    to: function (x) {
        return x;
    },
    from: function (x) {
        return x;
    }
};
var showQueryPairs = function (dictShow) {
    return function (dictShow1) {
        return {
            show: Data_Show_Generic.genericShow(genericQueryPairs)(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsArgument(Data_Show.showArray(Data_Tuple.showTuple(dictShow)(Data_Maybe.showMaybe(dictShow1)))))({
                reflectSymbol: function () {
                    return "QueryPairs";
                }
            }))
        };
    };
};
var eqValue = Data_Eq.eqString;
var eqQueryPairs = function (dictEq) {
    return function (dictEq1) {
        return Data_Eq.eqArray(Data_Tuple.eqTuple(dictEq)(Data_Maybe.eqMaybe(dictEq1)));
    };
};
var eqKey = Data_Eq.eqString;
module.exports = {
    QueryPairs: QueryPairs,
    parse: parse,
    print: print,
    keyPartChar: keyPartChar,
    valuePartChar: valuePartChar,
    keyFromString: keyFromString,
    keyToString: keyToString,
    unsafeKeyFromString: unsafeKeyFromString,
    unsafeKeyToString: unsafeKeyToString,
    valueFromString: valueFromString,
    valueToString: valueToString,
    unsafeValueFromString: unsafeValueFromString,
    unsafeValueToString: unsafeValueToString,
    eqQueryPairs: eqQueryPairs,
    ordQueryPairs: ordQueryPairs,
    genericQueryPairs: genericQueryPairs,
    showQueryPairs: showQueryPairs,
    semigroupQueryPairs: semigroupQueryPairs,
    monoidQueryPairs: monoidQueryPairs,
    eqKey: eqKey,
    ordKey: ordKey,
    semigroupKey: semigroupKey,
    monoidKey: monoidKey,
    showKey: showKey,
    eqValue: eqValue,
    ordValue: ordValue,
    semigroupValue: semigroupValue,
    monoidValue: monoidValue,
    showValue: showValue
};
