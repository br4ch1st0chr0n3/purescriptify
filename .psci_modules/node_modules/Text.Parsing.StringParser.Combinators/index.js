
// | This module defines combinators for building string parsers.
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Lazy = require("../Control.Lazy/index.js");
var Control_Monad_Rec_Class = require("../Control.Monad.Rec.Class/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_NonEmpty = require("../Data.List.NonEmpty/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_NonEmpty = require("../Data.NonEmpty/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Text_Parsing_StringParser = require("../Text.Parsing.StringParser/index.js");

// | Provide an error message in case of failure.
var withError = function (p) {
    return function (msg) {
        return Control_Alt.alt(Text_Parsing_StringParser.altParser)(p)(Text_Parsing_StringParser.fail(msg));
    };
};

// | Attempt to parse a value.
var optional = function (p) {
    return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (v) {
        return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_Unit.unit);
    }))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_Unit.unit));
};

// | Parse a value with a default value in case of failure.
var option = function (a) {
    return function (p) {
        return Control_Alt.alt(Text_Parsing_StringParser.altParser)(p)(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(a));
    };
};

// | Attempt to parse a value, pureing `Nothing` in case of failure.
var optionMaybe = function (p) {
    return option(Data_Maybe.Nothing.value)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_Maybe.Just.create)(p));
};

// | Parse values until the terminator matches, requiring at least one match.
var many1Till = function (p) {
    return function (end) {
        var ending = function (acc) {
            return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(end)(function () {
                return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(new Control_Monad_Rec_Class.Done(Data_List_NonEmpty.reverse(acc)));
            });
        };
        var $$continue = function (acc) {
            return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (c) {
                return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(new Control_Monad_Rec_Class.Loop(Data_List_NonEmpty.cons(c)(acc)));
            });
        };
        var inner = function (acc) {
            return Control_Alt.alt(Text_Parsing_StringParser.altParser)(ending(acc))($$continue(acc));
        };
        return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (x) {
            return Control_Monad_Rec_Class.tailRecM(Text_Parsing_StringParser.monadRecParser)(inner)(Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList)(x));
        });
    };
};

// | Parse values until a terminator.
var manyTill = function (p) {
    return function (end) {
        return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(end)(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_List_Types.Nil.value)))(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_NonEmpty.toList)(many1Till(p)(end)));
    };
};

// | Match zero or more times.
var many = Data_List.manyRec(Text_Parsing_StringParser.monadRecParser)(Text_Parsing_StringParser.alternativeParser);

// | Read ahead without consuming input.
var lookAhead = function (v) {
    return function (s) {
        var v1 = v(s);
        if (v1 instanceof Data_Either.Right) {
            return new Data_Either.Right({
                result: v1.value0.result,
                suffix: s
            });
        };
        return v1;
    };
};

// | Parse zero or more separated values, ending with a separator.
var endBy = function (p) {
    return function (sep) {
        return many(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(p)(sep));
    };
};
var cons$prime = function (h) {
    return function (t) {
        return new Data_NonEmpty.NonEmpty(h, t);
    };
};

// | Match one or more times.
var many1 = function (p) {
    return Control_Apply.apply(Text_Parsing_StringParser.applyParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(cons$prime)(p))(many(p));
};

// | Parse one or more separated values, ending with a separator.
var endBy1 = function (p) {
    return function (sep) {
        return many1(Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(p)(sep));
    };
};

// | Parse one or more separated values.
var sepBy1 = function (p) {
    return function (sep) {
        return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (a) {
            return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(many(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(sep)(p)))(function (as) {
                return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(cons$prime(a)(as));
            });
        });
    };
};

// | Parse zero or more separated values.
var sepBy = function (p) {
    return function (sep) {
        return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_NonEmpty.toList)(sepBy1(p)(sep)))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_List_Types.Nil.value));
    };
};

// | Parse one or more separated values, optionally ending with a separator.
var sepEndBy1 = function (p) {
    return function (sep) {
        return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (a) {
            return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Control_Bind.bind(Text_Parsing_StringParser.bindParser)(sep)(function () {
                return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(sepEndBy(p)(sep))(function (as) {
                    return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(cons$prime(a)(as));
                });
            }))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_List_NonEmpty.singleton(a)));
        });
    };
};

// | Parse zero or more separated values, optionally ending with a separator.
var sepEndBy = function (p) {
    return function (sep) {
        return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Data_Functor.map(Text_Parsing_StringParser.functorParser)(Data_List_NonEmpty.toList)(sepEndBy1(p)(sep)))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_List_Types.Nil.value));
    };
};

// | Parse using any of a collection of parsers.
var choice = function (dictFoldable) {
    return Data_Foldable.foldl(dictFoldable)(Control_Alt.alt(Text_Parsing_StringParser.altParser))(Text_Parsing_StringParser.fail("Nothing to parse"));
};

// | Parse one or more values separated by a right-associative operator.
var chainr1$prime = function (p) {
    return function (f) {
        return function (a) {
            return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Control_Bind.bind(Text_Parsing_StringParser.bindParser)(f)(function (f$prime) {
                return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(chainr1(p)(f))(function (a$prime) {
                    return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(f$prime(a)(a$prime));
                });
            }))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(a));
        };
    };
};

// | Parse one or more values separated by a right-associative operator.
var chainr1 = function (p) {
    return function (f) {
        return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (a) {
            return chainr1$prime(p)(f)(a);
        });
    };
};

// | Parse zero or more values separated by a right-associative operator.
var chainr = function (p) {
    return function (f) {
        return function (a) {
            return Control_Alt.alt(Text_Parsing_StringParser.altParser)(chainr1(p)(f))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(a));
        };
    };
};

// | Parse one or more values separated by a left-associative operator.
var chainl1$prime = function (p) {
    return function (f) {
        return function (a) {
            return Control_Alt.alt(Text_Parsing_StringParser.altParser)(Control_Bind.bind(Text_Parsing_StringParser.bindParser)(f)(function (f$prime) {
                return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (a$prime) {
                    return chainl1$prime(p)(f)(f$prime(a)(a$prime));
                });
            }))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(a));
        };
    };
};

// | Parse one or more values separated by a left-associative operator.
var chainl1 = function (p) {
    return function (f) {
        return Control_Bind.bind(Text_Parsing_StringParser.bindParser)(p)(function (a) {
            return chainl1$prime(p)(f)(a);
        });
    };
};

// | Parse zero or more values separated by a left-associative operator.
var chainl = function (p) {
    return function (f) {
        return function (a) {
            return Control_Alt.alt(Text_Parsing_StringParser.altParser)(chainl1(p)(f))(Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(a));
        };
    };
};

// | Parse a string between opening and closing markers.
var between = function (open) {
    return function (close) {
        return function (p) {
            return Control_Apply.applyFirst(Text_Parsing_StringParser.applyParser)(Control_Apply.applySecond(Text_Parsing_StringParser.applyParser)(open)(p))(close);
        };
    };
};
module.exports = {
    lookAhead: lookAhead,
    many: many,
    many1: many1,
    withError: withError,
    between: between,
    option: option,
    optional: optional,
    optionMaybe: optionMaybe,
    sepBy: sepBy,
    sepBy1: sepBy1,
    sepEndBy: sepEndBy,
    sepEndBy1: sepEndBy1,
    endBy1: endBy1,
    endBy: endBy,
    chainr: chainr,
    chainl: chainl,
    chainl1: chainl1,
    "chainl1'": chainl1$prime,
    chainr1: chainr1,
    "chainr1'": chainr1$prime,
    choice: choice,
    manyTill: manyTill,
    many1Till: many1Till,
    fix: Control_Lazy.fix
};
