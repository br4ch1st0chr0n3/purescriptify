
// | This module defines an applicative functor for _applicative validation_.
// |
// | Applicative validation differs from monadic validation using `Either` in
// | that it allows us to collect multiple errors using a `Semigroup`, whereas
// | `Either` terminates on the first error.
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");

// | The `V` functor, used for applicative validation
// |
// | The `Applicative` instance collects multiple failures in
// | an arbitrary `Semigroup`.
// |
// | For example:
// |
// | ```purescript
// | validate :: Person -> V (Array Error) Person
// | validate person = { first: _, last: _, email: _ }
// |   <$> validateName person.first
// |   <*> validateName person.last
// |   <*> validateEmail person.email
// | ```
var V = function (x) {
    return x;
};

// | Takes two functions an a `V` value, if the validation failed the error is
// | applied to the first function, if the validation succeeded the inner value
// | is applied to the second function.
var validation = function (v) {
    return function (v1) {
        return function (v2) {
            if (v2 instanceof Data_Either.Left) {
                return v(v2.value0);
            };
            if (v2 instanceof Data_Either.Right) {
                return v1(v2.value0);
            };
            throw new Error("Failed pattern match at Data.Validation.Semigroup (line 50, column 1 - line 50, column 84): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
        };
    };
};

// | Deprecated previous name of `validation`.
var unV = function () {
    return validation;
};
var toEither = function (v) {
    return v;
};
var showV = function (dictShow) {
    return function (dictShow1) {
        return {
            show: function (v) {
                if (v instanceof Data_Either.Left) {
                    return "invalid (" + (Data_Show.show(dictShow)(v.value0) + ")");
                };
                if (v instanceof Data_Either.Right) {
                    return "pure (" + (Data_Show.show(dictShow1)(v.value0) + ")");
                };
                throw new Error("Failed pattern match at Data.Validation.Semigroup (line 87, column 10 - line 89, column 55): " + [ v.constructor.name ]);
            }
        };
    };
};
var newtypeV = {
    Coercible0: function () {
        return undefined;
    }
};

// | Test whether validation was successful or not.
var isValid = function (v) {
    if (v instanceof Data_Either.Right) {
        return true;
    };
    return false;
};

// | Fail with a validation error.
var invalid = function ($58) {
    return V(Data_Either.Left.create($58));
};
var functorV = Data_Either.functorEither;
var foldableV = {
    foldMap: function (dictMonoid) {
        return validation(Data_Function["const"](Data_Monoid.mempty(dictMonoid)));
    },
    foldr: function (f) {
        return function (b) {
            return validation(Data_Function["const"](b))(Data_Function.flip(f)(b));
        };
    },
    foldl: function (f) {
        return function (b) {
            return validation(Data_Function["const"](b))(f(b));
        };
    }
};
var traversableV = {
    sequence: function (dictApplicative) {
        return validation((function () {
            var $59 = Control_Applicative.pure(dictApplicative);
            return function ($60) {
                return $59(V(Data_Either.Left.create($60)));
            };
        })())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($61) {
            return V(Data_Either.Right.create($61));
        }));
    },
    traverse: function (dictApplicative) {
        return function (f) {
            return validation((function () {
                var $62 = Control_Applicative.pure(dictApplicative);
                return function ($63) {
                    return $62(V(Data_Either.Left.create($63)));
                };
            })())((function () {
                var $64 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($66) {
                    return V(Data_Either.Right.create($66));
                });
                return function ($65) {
                    return $64(f($65));
                };
            })());
        };
    },
    Functor0: function () {
        return functorV;
    },
    Foldable1: function () {
        return foldableV;
    }
};
var eqV = function (dictEq) {
    return function (dictEq1) {
        return {
            eq: function (x) {
                return function (y) {
                    return Data_Eq.eq(Data_Either.eqEither(dictEq)(dictEq1))(x)(y);
                };
            }
        };
    };
};
var ordV = function (dictOrd) {
    return function (dictOrd1) {
        return {
            compare: function (x) {
                return function (y) {
                    return Data_Ord.compare(Data_Either.ordEither(dictOrd)(dictOrd1))(x)(y);
                };
            },
            Eq0: function () {
                return eqV(dictOrd.Eq0())(dictOrd1.Eq0());
            }
        };
    };
};
var eq1V = function (dictEq) {
    return {
        eq1: function (dictEq1) {
            return Data_Eq.eq(eqV(dictEq)(dictEq1));
        }
    };
};
var ord1V = function (dictOrd) {
    return {
        compare1: function (dictOrd1) {
            return Data_Ord.compare(ordV(dictOrd)(dictOrd1));
        },
        Eq10: function () {
            return eq1V(dictOrd.Eq0());
        }
    };
};
var bifunctorV = Data_Bifunctor.bifunctorEither;
var applyV = function (dictSemigroup) {
    return {
        apply: function (v) {
            return function (v1) {
                if (v instanceof Data_Either.Left && v1 instanceof Data_Either.Left) {
                    return new Data_Either.Left(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0));
                };
                if (v instanceof Data_Either.Left) {
                    return new Data_Either.Left(v.value0);
                };
                if (v1 instanceof Data_Either.Left) {
                    return new Data_Either.Left(v1.value0);
                };
                if (v instanceof Data_Either.Right && v1 instanceof Data_Either.Right) {
                    return new Data_Either.Right(v.value0(v1.value0));
                };
                throw new Error("Failed pattern match at Data.Validation.Semigroup (line 95, column 1 - line 99, column 54): " + [ v.constructor.name, v1.constructor.name ]);
            };
        },
        Functor0: function () {
            return functorV;
        }
    };
};
var semigroupV = function (dictSemigroup) {
    return function (dictSemigroup1) {
        return {
            append: Control_Apply.lift2(applyV(dictSemigroup))(Data_Semigroup.append(dictSemigroup1))
        };
    };
};
var applicativeV = function (dictSemigroup) {
    return {
        pure: function ($67) {
            return V(Data_Either.Right.create($67));
        },
        Apply0: function () {
            return applyV(dictSemigroup);
        }
    };
};
var monoidV = function (dictSemigroup) {
    return function (dictMonoid) {
        return {
            mempty: Control_Applicative.pure(applicativeV(dictSemigroup))(Data_Monoid.mempty(dictMonoid)),
            Semigroup0: function () {
                return semigroupV(dictSemigroup)(dictMonoid.Semigroup0());
            }
        };
    };
};

// | Apply a function if successful, to enable chaining of validation.
// |
// | Similar to a monadic bind, except it is inconsistent with Apply - that is,
// | where as apply accumulates failures: `apply (invalid x) (invalid y) = invalid (x <> y)`,
// | andThen has fail-fast semantics: `andThen (invalid x) (\_ -> invalid y) = invalid x`
// | (`>>=` would be expected to be consistent).
var andThen = function (v1) {
    return function (f) {
        return validation(invalid)(f)(v1);
    };
};
module.exports = {
    V: V,
    validation: validation,
    unV: unV,
    invalid: invalid,
    isValid: isValid,
    toEither: toEither,
    andThen: andThen,
    newtypeV: newtypeV,
    eqV: eqV,
    eq1V: eq1V,
    ordV: ordV,
    ord1V: ord1V,
    showV: showV,
    functorV: functorV,
    bifunctorV: bifunctorV,
    applyV: applyV,
    applicativeV: applicativeV,
    semigroupV: semigroupV,
    monoidV: monoidV,
    foldableV: foldableV,
    traversableV: traversableV
};
