"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_NonEmpty_CodeUnits = require("../Data.String.NonEmpty.CodeUnits/index.js");
var Data_String_NonEmpty_Internal = require("../Data.String.NonEmpty.Internal/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var URI_Common = require("../URI.Common/index.js");
var URI_UserInfo = require("../URI.UserInfo/index.js");

// | `user:password` formatted user-info components for URI authorities.
// |
// | This format is considered deprecated according to RFC3986 but is still
// | very common, so this is provided for cases where it is necessary.
// |
// | The username part is required, so a value like `:hello` will fail to parse
// | for this type.
// |
// | The `:` characer will be percent-encoded in all locations other than the
// | `user:password` separator, although the parser will accept passwords
// | containing un-encoded `:` characters.
var UserPassInfo = function (x) {
    return x;
};

// | The supported user/password characters, excluding percent-encodings.
var userPassInfoChar = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(URI_Common.unreserved)(URI_Common.subDelims);
var showUserPassInfo = {
    show: function (v) {
        return "(UserPassInfo { user: " + (Data_Show.show(Data_String_NonEmpty_Internal.showNonEmptyString)(v.user) + (", password: " + (Data_Show.show(Data_Maybe.showMaybe(Data_String_NonEmpty_Internal.showNonEmptyString))(v.password) + "})")));
    }
};

// | A printer for `user:password` formatted user-info.
var print = function (v) {
    if (v.password instanceof Data_Maybe.Nothing) {
        return URI_UserInfo.unsafeFromString(URI_Common["printEncoded'"](userPassInfoChar)(v.user));
    };
    if (v.password instanceof Data_Maybe.Just) {
        return URI_UserInfo.unsafeFromString(Data_Semigroup.append(Data_String_NonEmpty_Internal.semigroupNonEmptyString)(URI_Common["printEncoded'"](userPassInfoChar)(v.user))(Data_Semigroup.append(Data_String_NonEmpty_Internal.semigroupNonEmptyString)(Data_String_NonEmpty_CodeUnits.singleton(":"))(URI_Common["printEncoded'"](userPassInfoChar)(v.password.value0))));
    };
    throw new Error("Failed pattern match at URI.Extra.UserPassInfo (line 68, column 3 - line 75, column 44): " + [ v.password.constructor.name ]);
};

// | A parser for `user:password` formatted user-info.
var parse = function (ui) {
    var s = URI_UserInfo.unsafeToString(ui);
    var v = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_String_NonEmpty_CodeUnits.splitAt)(s))(Data_String_NonEmpty_CodeUnits.indexOf(":")(s));
    if (v instanceof Data_Maybe.Just && v.value0.before instanceof Data_Maybe.Nothing) {
        return new Data_Either.Left("Expected a username before a password segment");
    };
    if (v instanceof Data_Maybe.Just && (v.value0.before instanceof Data_Maybe.Just && v.value0.after instanceof Data_Maybe.Just)) {
        return new Data_Either.Right({
            user: URI_Common["decodeURIComponent'"](v.value0.before.value0),
            password: Data_Functor.map(Data_Maybe.functorMaybe)(URI_Common["decodeURIComponent'"])(Data_String_NonEmpty_CodeUnits.drop(1)(v.value0.after.value0))
        });
    };
    return new Data_Either.Right({
        user: URI_Common["decodeURIComponent'"](s),
        password: Data_Maybe.Nothing.value
    });
};
var newtypeUserPassInfo = {
    Coercible0: function () {
        return undefined;
    }
};
var eqUserPassInfo = {
    eq: function (x) {
        return function (y) {
            return Data_Eq.eq(Data_Maybe.eqMaybe(Data_String_NonEmpty_Internal.eqNonEmptyString))(x.password)(y.password) && Data_Eq.eq(Data_String_NonEmpty_Internal.eqNonEmptyString)(x.user)(y.user);
        };
    }
};
var ordUserPassInfo = {
    compare: function (x) {
        return function (y) {
            var v = Data_Ord.compare(Data_Maybe.ordMaybe(Data_String_NonEmpty_Internal.ordNonEmptyString))(x.password)(y.password);
            if (v instanceof Data_Ordering.LT) {
                return Data_Ordering.LT.value;
            };
            if (v instanceof Data_Ordering.GT) {
                return Data_Ordering.GT.value;
            };
            return Data_Ord.compare(Data_String_NonEmpty_Internal.ordNonEmptyString)(x.user)(y.user);
        };
    },
    Eq0: function () {
        return eqUserPassInfo;
    }
};
module.exports = {
    UserPassInfo: UserPassInfo,
    parse: parse,
    print: print,
    userPassInfoChar: userPassInfoChar,
    eqUserPassInfo: eqUserPassInfo,
    ordUserPassInfo: ordUserPassInfo,
    newtypeUserPassInfo: newtypeUserPassInfo,
    showUserPassInfo: showUserPassInfo
};
