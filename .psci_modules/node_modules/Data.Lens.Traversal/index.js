
// | `Traversal` is an optic that focuses on zero or more values. An
// | `Array` would be a typical example:
// |
// | ```purescript
// | over    traversed negate [1, 2, 3] == [-1, -2, -3]
// | preview traversed [1, 2, 3] == Just 1
// | firstOf traversed [1, 2, 3] == Just 1  -- same as `preview`
// | lastOf  traversed [1, 2, 3] == Just 3
// | ```
// |
// | `view` might surprise you. It assumes that the wrapped values
// | are a monoid, and `append`s them together:
// |
// | ```purescript
// | view traversed ["D", "a", "w", "n"] == "Dawn"
// | ```
// |
// | Many of the functions you'll use are documented in `Data.Lens.Fold`. 
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Plus = require("../Control.Plus/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Lens_Indexed = require("../Data.Lens.Indexed/index.js");
var Data_Lens_Internal_Bazaar = require("../Data.Lens.Internal.Bazaar/index.js");
var Data_Lens_Internal_Indexed = require("../Data.Lens.Internal.Indexed/index.js");
var Data_Lens_Internal_Wander = require("../Data.Lens.Internal.Wander/index.js");
var Data_Lens_Types = require("../Data.Lens.Types/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Profunctor_Star = require("../Data.Profunctor.Star/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");

// | A `Traversal` for the elements of a `Traversable` functor.
// |
// | ```purescript
// | over traversed negate [1, 2, 3] == [-1,-2,-3]
// | over traversed negate (Just 3) == Just -3
// | ```
var traversed = function (dictTraversable) {
    return function (dictWander) {
        return Data_Lens_Internal_Wander.wander(dictWander)(function (dictApplicative) {
            return Data_Traversable.traverse(dictTraversable)(dictApplicative);
        });
    };
};

// | Turn a pure profunctor `Traversal` into a `lens`-like `Traversal`.
var traverseOf = Data_Newtype.under()()(Data_Profunctor_Star.Star);

// | Sequence the foci of an optic, pulling out an "effect".
// | If you do not need the result, see `sequenceOf_` for `Fold`s.
// |
// | `sequenceOf traversed` has the same result as `Data.Traversable.sequence`:
// |
// | ```purescript
// | sequenceOf traversed (Just [1, 2]) == [Just 1, Just 2]
// | sequence             (Just [1, 2]) == [Just 1, Just 2]
// | ```
// |
// | An example with effects:
// | ```purescript
// | > array = [random, random]
// | > :t array
// | Array (Eff ... Number)
// |
// | > effect = sequenceOf traversed array
// | > :t effect
// | Eff ... (Array Number)
// |
// | > effect >>= logShow
// | [0.15556037108154985,0.28500369615270515]
// | unit
// | ```
var sequenceOf = function (t) {
    return traverseOf(t)(Control_Category.identity(Control_Category.categoryFn));
};

// | Turn a pure profunctor `IndexedTraversal` into a `lens`-like `IndexedTraversal`.
var itraverseOf = function (t) {
    var $24 = Data_Newtype.under()()(Data_Profunctor_Star.Star)(function ($26) {
        return t(Data_Lens_Internal_Indexed.Indexed($26));
    });
    return function ($25) {
        return $24(Data_Tuple.uncurry($25));
    };
};

// | Flipped version of `itraverseOf`.
var iforOf = function ($27) {
    return Data_Function.flip(itraverseOf($27));
};

// | Tries to map over a `Traversal`; returns `empty` if the traversal did
// | not have any new focus.
var failover = function (dictAlternative) {
    return function (t) {
        return function (f) {
            return function (s) {
                var v = Data_Newtype.unwrap()(t((function () {
                    var $28 = Data_Tuple.Tuple.create(true);
                    return function ($29) {
                        return $28(f($29));
                    };
                })()))(s);
                if (v.value0) {
                    return Control_Applicative.pure(dictAlternative.Applicative0())(v.value1);
                };
                if (!v.value0) {
                    return Control_Plus.empty(dictAlternative.Plus1());
                };
                throw new Error("Failed pattern match at Data.Lens.Traversal (line 98, column 18 - line 100, column 32): " + [ v.constructor.name ]);
            };
        };
    };
};

// | Traverse elements of an `IndexedTraversal` whose index satisfy a predicate.
var elementsOf = function (dictWander) {
    return function (tr) {
        return function (pr) {
            return Data_Lens_Indexed.iwander(function (dictApplicative) {
                return function (f) {
                    return Data_Newtype.unwrap()(tr(Data_Lens_Internal_Wander.wanderStar(dictApplicative))(function (v) {
                        var $21 = pr(v.value0);
                        if ($21) {
                            return f(v.value0)(v.value1);
                        };
                        return Control_Applicative.pure(dictApplicative)(v.value1);
                    }));
                };
            })(dictWander);
        };
    };
};

// | Combine an index and a traversal to narrow the focus to a single
// | element. Compare to `Data.Lens.Index`. 
// |
// | ```purescript
// | set     (element 2 traversed) 8888 [0, 0, 3] == [0, 0, 8888]
// | preview (element 2 traversed)      [0, 0, 3] == Just 3
// | ```
// | The resulting traversal is called an *affine traversal*, which
// | means that the traversal focuses on one or zero (if the index is out of range)
// | results.
var element = function (dictWander) {
    return function (n) {
        return function (tr) {
            return Data_Lens_Indexed.unIndex((dictWander.Choice1()).Profunctor0())(elementsOf(dictWander)(function (dictWander1) {
                return Data_Lens_Indexed.positions(function (dictWander2) {
                    return tr(dictWander2);
                })(dictWander1);
            })(function (v) {
                return v === n;
            }));
        };
    };
};
var cloneTraversal = function (l) {
    return function (dictWander) {
        return Data_Lens_Internal_Wander.wander(dictWander)(function (dictApplicative) {
            return Data_Lens_Internal_Bazaar.runBazaar(l(function (dictApplicative1) {
                return Control_Category.identity(Control_Category.categoryFn);
            }))(dictApplicative);
        });
    };
};
module.exports = {
    traversed: traversed,
    element: element,
    traverseOf: traverseOf,
    sequenceOf: sequenceOf,
    failover: failover,
    elementsOf: elementsOf,
    itraverseOf: itraverseOf,
    iforOf: iforOf,
    cloneTraversal: cloneTraversal
};
