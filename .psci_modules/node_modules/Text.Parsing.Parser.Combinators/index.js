
// | ## Combinators in other packages
// |
// | Many variations of well-known monadic and applicative combinators used for parsing are
// | defined in other PureScript packages. Itâ€™s awkward to re-export
// | them because their names overlap so much, so we list them here.
// |
// | ### Data.Array
// | * [Data.Array.many](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:many)
// | * [Data.Array.some](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array#v:some)
// |
// | ### Data.Array.NonEmpty
// | * [Data.Array.NonEmpty.some](https://pursuit.purescript.org/packages/purescript-arrays/docs/Data.Array.NonEmpty#v:some)
// |
// | ### Data.List
// | * [Data.List.many](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List#v:many)
// | * [Data.List.some](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List#v:some)
// | * [Data.List.someRec](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List#v:someRec)
// | * [Data.List.manyRec](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List#v:manyRec)
// |
// | ### Data.List.NonEmpty
// | * See the __many1__ combinator below.
// |
// | ### Data.List.Lazy
// | * [Data.List.Lazy.many](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Lazy#v:many)
// | * [Data.List.Lazy.some](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Lazy#v:some)
// | * [Data.List.Lazy.replicateM](https://pursuit.purescript.org/packages/purescript-lists/docs/Data.List.Lazy#v:replicateM)
// |
// | ## Combinators in this package
// |
// | A parser combinator is a function which takes some
// | parsers as arguments and returns a new parser.
// |
// | The __many__ combinator applied to parser `p :: Parser s a` will return
// | a parser `many p :: Parser s (Array a)` which will repeat the
// | parser `p` as many times as possible. If `p` never consumes input when it
// | fails then `many p` will always succeed
// | but may return an empty array.
// |
// | The __replicateA n__ combinator applied to parser `p :: Parser s a` will
// | return a parser `replicateA n p :: Parser s (Array a)` which will
// | repeat parser `p` exactly `n` times. `replicateA n p` will only succeed
// | if it can match parser `p` exactly `n` consecutive times.
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Lazy = require("../Control.Lazy/index.js");
var Control_Monad_Except_Trans = require("../Control.Monad.Except.Trans/index.js");
var Control_Monad_Rec_Class = require("../Control.Monad.Rec.Class/index.js");
var Control_Monad_State_Trans = require("../Control.Monad.State.Trans/index.js");
var Control_Plus = require("../Control.Plus/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_NonEmpty = require("../Data.List.NonEmpty/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Unfoldable1 = require("../Data.Unfoldable1/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");

// | Provide an error message in the case of failure, but lazily. This is handy
// | in cases where constructing the error message is expensive, so it's
// | preferable to defer it until an error actually happens.
// |
// |```purs
// |parseBang :: Parser Char
// |parseBang = char '!' <~?> \_ -> "Expected a bang"
// |```
var withLazyErrorMessage = function (dictMonad) {
    return function (p) {
        return function (msg) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(p)(Control_Lazy.defer(Text_Parsing_Parser.lazyParserT)(function (v) {
                return Text_Parsing_Parser.fail(dictMonad)("Expected " + msg(Data_Unit.unit));
            }));
        };
    };
};

// | Provide an error message in the case of failure.
var withErrorMessage = function (dictMonad) {
    return function (p) {
        return function (msg) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(p)(Text_Parsing_Parser.fail(dictMonad)("Expected " + msg));
        };
    };
};

// | If the parser fails then backtrack the input stream to the unconsumed state.
// |
// | Like `try`, but will relocate the error to the `try` point.
// |
// | ```
// | >>> runParser "ac" (try (char 'a' *> char 'b'))
// | Left (ParseError "Expected 'b'" (Position { line: 1, column: 2 }))
// | ```
// |
// | ```
// | >>> runParser "ac" (tryRethrow (char 'a' *> char 'b'))
// | Left (ParseError "Expected 'b'" (Position { line: 1, column: 1 }))
// | ```
var tryRethrow = function (dictMonad) {
    return function (p) {
        return Text_Parsing_Parser.ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (v) {
            return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p)))(v))(function (v1) {
                if (v1.value0 instanceof Data_Either.Left) {
                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(new Data_Either.Left(new Text_Parsing_Parser.ParseError(v1.value0.value0.value0, v.value1)), new Text_Parsing_Parser.ParseState(v1.value1.value0, v1.value1.value1, v.value2)));
                };
                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, v1.value1));
            });
        })));
    };
};

// | If the parser fails then backtrack the input stream to the unconsumed state.
// |
// | One use for this combinator is to ensure that the right parser of an
// | alternative will always be tried when the left parser fails.
// | ```
// | >>> runParser "ac" ((char 'a' *> char 'b') <|> (char 'a' *> char 'c'))
// | Left (ParseError "Expected 'b'" (Position { line: 1, column: 2 }))
// | ```
// |
// | ```
// | >>> runParser "ac" (try (char 'a' *> char 'b') <|> (char 'a' *> char 'c'))
// | Right 'c'
// | ```
var $$try = function (dictMonad) {
    return function (p) {
        return Text_Parsing_Parser.ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (v) {
            return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p)))(v))(function (v1) {
                if (v1.value0 instanceof Data_Either.Left) {
                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, new Text_Parsing_Parser.ParseState(v1.value1.value0, v1.value1.value1, v.value2)));
                };
                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, v1.value1));
            });
        })));
    };
};

// | Skip at least one instance of a phrase.
// |
// | Stack-safe version of `skipMany1` at the expense of a `MonadRec` constraint.
var skipMany1Rec = function (dictMonadRec) {
    return function (p) {
        var go = function (v) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(p)(new Control_Monad_Rec_Class.Loop(Data_Unit.unit)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Done(Data_Unit.unit)));
        };
        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonadRec.Monad0()))(p)(Control_Monad_Rec_Class.tailRecM(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(go)(Data_Unit.unit));
    };
};

// | Skip many instances of a phrase.
// |
// | Stack-safe version of `skipMany` at the expense of a `MonadRec` constraint.
var skipManyRec = function (dictMonadRec) {
    return function (p) {
        return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(skipMany1Rec(dictMonadRec)(p))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(Data_Unit.unit));
    };
};

// | Skip at least one instance of a phrase.
var skipMany1 = function (dictMonad) {
    return function (p) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function () {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(skipMany(dictMonad)(p))(function () {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit);
            });
        });
    };
};

// | Skip many instances of a phrase.
var skipMany = function (dictMonad) {
    return function (p) {
        return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(skipMany1(dictMonad)(p))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit));
    };
};

// | Parse phrases delimited and optionally terminated by a separator, requiring at least one match.
// |
// | Stack-safe version of `sepEndBy1` at the expense of a `MonadRec` constraint.
var sepEndBy1Rec = function (dictMonadRec) {
    return function (p) {
        return function (sep) {
            var go = function (acc) {
                var done = Control_Lazy.defer(Text_Parsing_Parser.lazyParserT)(function (v) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Done(Data_List.reverse(acc)));
                });
                var nextOne = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(sep)(function () {
                    return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(p)(function (a) {
                        return new Control_Monad_Rec_Class.Loop(new Data_List_Types.Cons(a, acc));
                    }))(done);
                });
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(nextOne)(done);
            };
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Data_Functor.map(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty["cons'"](a))(Control_Monad_Rec_Class.tailRecM(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(go)(Data_List_Types.Nil.value)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(Data_List_NonEmpty.singleton(a)));
            });
        };
    };
};

// | Parse phrases delimited and optionally terminated by a separator.
// |
// | Stack-safe version of `sepEndBy` at the expense of a `MonadRec` constraint.
var sepEndByRec = function (dictMonadRec) {
    return function (p) {
        return function (sep) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Data_Functor.map(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty.toList)(sepEndBy1Rec(dictMonadRec)(p)(sep)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(Data_List_Types.Nil.value));
        };
    };
};

// | Parse phrases delimited and optionally terminated by a separator, requiring at least one match.
var sepEndBy1 = function (dictMonad) {
    return function (p) {
        return function (sep) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(sep)(function () {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(sepEndBy(dictMonad)(p)(sep))(function (as) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty["cons'"](a)(as));
                    });
                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty.singleton(a)));
            });
        };
    };
};

// | Parse phrases delimited and optionally terminated by a separator.
var sepEndBy = function (dictMonad) {
    return function (p) {
        return function (sep) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty.toList)(sepEndBy1(dictMonad)(p)(sep)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_Types.Nil.value));
        };
    };
};

// | Parse phrases delimited by a separator, requiring at least one match.
// |
// | Stack-safe version of `sepBy1` at the expense of a `MonadRec` constraint.
var sepBy1Rec = function (dictMonadRec) {
    return function (p) {
        return function (sep) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (a) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(Data_List.manyRec(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(Text_Parsing_Parser.alternativeParserT(dictMonadRec.Monad0()))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonadRec.Monad0()))(sep)(p)))(function (as) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(Data_List_NonEmpty["cons'"](a)(as));
                });
            });
        };
    };
};

// | Parse phrases delimited by a separator.
// |
// | Stack-safe version of `sepBy` at the expense of a `MonadRec` constraint.
var sepByRec = function (dictMonadRec) {
    return function (p) {
        return function (sep) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Data_Functor.map(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty.toList)(sepBy1Rec(dictMonadRec)(p)(sep)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(Data_List_Types.Nil.value));
        };
    };
};

// | Parse phrases delimited by a separator, requiring at least one match.
var sepBy1 = function (dictMonad) {
    return function (p) {
        return function (sep) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(sep)(p)))(function (as) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty["cons'"](a)(as));
                });
            });
        };
    };
};

// | Parse phrases delimited by a separator.
// |
// | For example:
// |
// | ```purescript
// | digit `sepBy` string ","
// | ```
var sepBy = function (dictMonad) {
    return function (p) {
        return function (sep) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty.toList)(sepBy1(dictMonad)(p)(sep)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_Types.Nil.value));
        };
    };
};

// | Optionally parse something, failing quietly.
// |
// | To optionally parse `p` and never fail: `optional (try p)`.
var optional = function (dictMonad) {
    return function (p) {
        return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor["void"](Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(p))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit));
    };
};

// | Provide a default result in the case where a parser fails without consuming input.
var option = function (dictMonad) {
    return function (a) {
        return function (p) {
            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(p)(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));
        };
    };
};

// TODO Is this optional parser correct? Isn't this parser supposed to succeed
// even if p fails? Otherwise what's the point? I think we need try (void p).
// | pure `Nothing` in the case where a parser fails without consuming input.
var optionMaybe = function (dictMonad) {
    return function (p) {
        return option(dictMonad)(Data_Maybe.Nothing.value)(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Maybe.Just.create)(p));
    };
};

// | Fail if the parser succeeds.
// |
// | Will never consume input.
var notFollowedBy = function (dictMonad) {
    return function (p) {
        return $$try(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))($$try(dictMonad)(p))(Text_Parsing_Parser.fail(dictMonad)("Negated parser succeeded")))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit)));
    };
};

// | Parse many phrases until the terminator phrase matches.
// | Returns the list of phrases and the terminator phrase.
// |
// | Use the __manyTill_ __ combinator
// | to do non-greedy repetition of a pattern `p`, like we would in Regex
// | by writing `p*?`.
// | To repeat pattern `p` non-greedily, write
// | `manyTill_ p q` where `q` is the entire rest of the parser.
// |
// | For example, this parse fails because `many` repeats the pattern `letter`
// | greedily.
// |
// | ```
// | runParser "aab" do
// |   a <- many letter
// |   b <- char 'b'
// |   pure (Tuple a b)
// | ```
// | ```
// | (ParseError "Expected 'b'" (Position { line: 1, column: 4 }))
// | ```
// |
// | To repeat pattern `letter` non-greedily, use `manyTill_`.
// |
// | ```
// | runParser "aab" do
// |   Tuple a b <- manyTill_ letter do
// |     char 'b'
// |   pure (Tuple a b)
// | ```
// | ```
// | (Tuple ('a' : 'a' : Nil) 'b')
// | ```
var manyTill_ = function (dictMonad) {
    return function (p) {
        return function (end) {
            var scan = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(end)(function (t) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_Tuple.Tuple(Data_List_Types.Nil.value, t));
            }))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (x) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(scan)(function (v) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_Tuple.Tuple(new Data_List_Types.Cons(x, v.value0), v.value1));
                });
            }));
            return scan;
        };
    };
};

// | Parse many phrases until the terminator phrase matches.
// | Returns the list of phrases and the terminator phrase.
// |
// | Stack-safe version of `manyTill_` at the expense of a `MonadRec` constraint.
var manyTillRec_ = function (dictMonadRec) {
    return function (p) {
        return function (end) {
            var go = function (xs) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(end)(function (t) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Done(new Data_Tuple.Tuple(Data_List.reverse(xs), t)));
                }))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (x) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Loop(new Data_List_Types.Cons(x, xs)));
                }));
            };
            return Control_Monad_Rec_Class.tailRecM(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(go)(Data_List_Types.Nil.value);
        };
    };
};

// | Parse many phrases until the terminator phrase matches.
// |
// | Stack-safe version of `manyTill` at the expense of a `MonadRec` constraint.
var manyTillRec = function (dictMonadRec) {
    return function (p) {
        return function (end) {
            var go = function (acc) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(end)(function (v) {
                    return new Control_Monad_Rec_Class.Done(Data_List.reverse(acc));
                }))(Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(p)(function (x) {
                    return new Control_Monad_Rec_Class.Loop(new Data_List_Types.Cons(x, acc));
                }));
            };
            return Control_Monad_Rec_Class.tailRecM(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(go)(Data_List_Types.Nil.value);
        };
    };
};

// | Parse many phrases until the terminator phrase matches.
var manyTill = function (dictMonad) {
    return function (p) {
        return function (end) {
            var scan = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(end)(Data_List_Types.Nil.value))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (x) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(scan)(function (xs) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_List_Types.Cons(x, xs));
                });
            }));
            return scan;
        };
    };
};

// | Parse many phrases until the terminator phrase matches, requiring at least one match.
// | Returns the list of phrases and the terminator phrase.
var many1Till_ = function (dictMonad) {
    return function (p) {
        return function (end) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (x) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(manyTill_(dictMonad)(p)(end))(function (v) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_Tuple.Tuple(Data_List_NonEmpty["cons'"](x)(v.value0), v.value1));
                });
            });
        };
    };
};

// | Parse many phrases until the terminator phrase matches, requiring at least one match.
// | Returns the list of phrases and the terminator phrase.
// |
// | Stack-safe version of `many1Till_` at the expense of a `MonadRec` constraint.
var many1TillRec_ = function (dictMonadRec) {
    return function (p) {
        return function (end) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (x) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(manyTillRec_(dictMonadRec)(p)(end))(function (v) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Data_Tuple.Tuple(Data_List_NonEmpty["cons'"](x)(v.value0), v.value1));
                });
            });
        };
    };
};

// | Parse at least one phrase until the terminator phrase matches.
// |
// | Stack-safe version of `many1Till` at the expense of a `MonadRec` constraint.
var many1TillRec = function (dictMonadRec) {
    return function (p) {
        return function (end) {
            return Control_Apply.apply(Text_Parsing_Parser.applyParserT(dictMonadRec.Monad0()))(Data_Functor.map(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty["cons'"])(p))(manyTillRec(dictMonadRec)(p)(end));
        };
    };
};

// | Parse at least one phrase until the terminator phrase matches.
var many1Till = function (dictMonad) {
    return function (p) {
        return function (end) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (x) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(manyTill(dictMonad)(p)(end))(function (xs) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty["cons'"](x)(xs));
                });
            });
        };
    };
};

// | Match one or more times.
// |
// | Stack-safe version of `many1` at the expense of a `MonadRec` constraint.
var many1Rec = function (dictMonadRec) {
    return function (p) {
        return Control_Apply.apply(Text_Parsing_Parser.applyParserT(dictMonadRec.Monad0()))(Data_Functor.map(Text_Parsing_Parser.functorParserT((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty["cons'"])(p))(Data_List.manyRec(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(Text_Parsing_Parser.alternativeParserT(dictMonadRec.Monad0()))(p));
    };
};

// | Match one or more times.
var many1 = function (dictMonad) {
    return function (p) {
        return Control_Apply.apply(Text_Parsing_Parser.applyParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty["cons'"])(p))(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(p));
    };
};

// | Parse a phrase, without modifying the consumed state or stream position.
var lookAhead = function (dictMonad) {
    return function (p) {
        return Text_Parsing_Parser.ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (s) {
            return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p)))(s))(function (v) {
                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v.value0, s));
            });
        })));
    };
};

// | Parse phrases delimited and terminated by a separator.
// |
// | Stack-safe version of `endBy` at the expense of a `MonadRec` constraint.
var endByRec = function (dictMonadRec) {
    return function (p) {
        return function (sep) {
            return Data_List.manyRec(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(Text_Parsing_Parser.alternativeParserT(dictMonadRec.Monad0()))(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonadRec.Monad0()))(p)(sep));
        };
    };
};

// | Parse phrases delimited and terminated by a separator, requiring at least one match.
// |
// | Stack-safe version of `endBy1` at the expense of a `MonadRec` constraint.
var endBy1Rec = function (dictMonadRec) {
    return function (p) {
        return function (sep) {
            return many1Rec(dictMonadRec)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonadRec.Monad0()))(p)(sep));
        };
    };
};

// | Parse phrases delimited and terminated by a separator, requiring at least one match.
var endBy1 = function (dictMonad) {
    return function (p) {
        return function (sep) {
            return many1(dictMonad)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(p)(sep));
        };
    };
};

// | Parse phrases delimited and terminated by a separator.
var endBy = function (dictMonad) {
    return function (p) {
        return function (sep) {
            return Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(p)(sep));
        };
    };
};

// | Parse one of a set of alternatives.
var choice = function (dictFoldable) {
    return function (dictMonad) {
        return Data_Foldable.foldl(dictFoldable)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad)))(Control_Plus.empty(Text_Parsing_Parser.plusParserT(dictMonad)));
    };
};

// | Parse phrases delimited by a right-associative operator, requiring at least one match.
// |
// | Stack-safe version of `chainr1` at the expense of a `MonadRec` constraint.
var chainr1Rec = function (dictMonadRec) {
    return function (p) {
        return function (f) {
            var apply = function (y) {
                return function (v) {
                    return v.value1(v.value0)(y);
                };
            };
            
            // This looks scary at first glance, so I'm leaving a comment in a vain
            // attempt to explain how it works.
            //
            // The loop state is a record {init, last}, where `last` is the last (i.e.
            // rightmost) `a` value that has been parsed so far, and `init` is a list of
            // (value + operator) pairs that have been parsed before that.
            //
            // The very first value is parsed at top level, and it becomes the initial
            // value of `last`, while the initial value of `init` is just `Nil`,
            // indicating that no pairs of (value + operator) have been parsed yet.
            //
            // At every step, we parse an operator and a value, and then the newly parsed
            // value becomes `last` (because, well, it's been parsed last), and the pair
            // of (previous last + operator) is prepended to `init`.
            //
            // After we can no longer parse a pair of (value + operation), we're done. At
            // that point, we have a list of (value + operation) pairs in reverse order
            // (since we prepend each pair as we go) and the very last value. All that's
            // left is combine them all via `foldl`.
var go = function (v) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(f)(function (op) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (a) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Loop({
                            last: a,
                            init: new Data_List_Types.Cons(new Data_Tuple.Tuple(v.last, op), v.init)
                        }));
                    });
                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Done(Data_Foldable.foldl(Data_List_Types.foldableList)(apply)(v.last)(v.init))));
            };
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (a) {
                return Control_Monad_Rec_Class.tailRecM(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(go)({
                    last: a,
                    init: Data_List_Types.Nil.value
                });
            });
        };
    };
};

// | Parse phrases delimited by a right-associative operator.
// |
// | Stack-safe version of `chainr` at the expense of a `MonadRec` constraint.
var chainrRec = function (dictMonadRec) {
    return function (p) {
        return function (f) {
            return function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(chainr1Rec(dictMonadRec)(p)(f))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(a));
            };
        };
    };
};

// | Parse phrases delimited by a right-associative operator, requiring at least one match.
var chainr1 = function (dictMonad) {
    return function (p) {
        return function (f) {
            var chainr1$prime = function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(f)(function (f$prime) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(chainr1(dictMonad)(p)(f))(function (a$prime) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(f$prime(a)(a$prime));
                    });
                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));
            };
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {
                return chainr1$prime(a);
            });
        };
    };
};

// | Parse phrases delimited by a right-associative operator.
// |
// | For example:
// |
// | ```purescript
// | chainr digit (string "+" $> add) 0
// | ```
var chainr = function (dictMonad) {
    return function (p) {
        return function (f) {
            return function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(chainr1(dictMonad)(p)(f))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));
            };
        };
    };
};

// | Parse phrases delimited by a left-associative operator, requiring at least one match.
// |
// | Stack-safe version of `chainl1` at the expense of a `MonadRec` constraint.
var chainl1Rec = function (dictMonadRec) {
    return function (p) {
        return function (f) {
            var go = function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(f)(function (op) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (a$prime) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Loop(op(a)(a$prime)));
                    });
                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(new Control_Monad_Rec_Class.Done(a)));
            };
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonadRec.Monad0()))(p)(function (a) {
                return Control_Monad_Rec_Class.tailRecM(Text_Parsing_Parser.monadRecParserT(dictMonadRec))(go)(a);
            });
        };
    };
};

// | Parse phrases delimited by a left-associative operator.
// |
// | Stack-safe version of `chainl` at the expense of a `MonadRec` constraint.
var chainlRec = function (dictMonadRec) {
    return function (p) {
        return function (f) {
            return function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonadRec.Monad0()))(chainl1Rec(dictMonadRec)(p)(f))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonadRec.Monad0()))(a));
            };
        };
    };
};

// | Parse phrases delimited by a left-associative operator, requiring at least one match.
var chainl1 = function (dictMonad) {
    return function (p) {
        return function (f) {
            var chainl1$prime = function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(f)(function (f$prime) {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a$prime) {
                        return chainl1$prime(f$prime(a)(a$prime));
                    });
                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));
            };
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {
                return chainl1$prime(a);
            });
        };
    };
};

// | Parse phrases delimited by a left-associative operator.
// |
// | For example:
// |
// | ```purescript
// | chainr digit (string "+" $> add) 0
// | ```
var chainl = function (dictMonad) {
    return function (p) {
        return function (f) {
            return function (a) {
                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(chainl1(dictMonad)(p)(f))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));
            };
        };
    };
};

// | Wrap a parser with opening and closing markers.
// |
// | For example:
// |
// | ```purescript
// | parens = between (string "(") (string ")")
// | ```
var between = function (dictMonad) {
    return function (open) {
        return function (close) {
            return function (p) {
                return Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(open)(p))(close);
            };
        };
    };
};

// | Flipped `(<?>)`.
var asErrorMessage = function (dictMonad) {
    return Data_Function.flip(withErrorMessage(dictMonad));
};
module.exports = {
    asErrorMessage: asErrorMessage,
    between: between,
    chainl: chainl,
    chainl1: chainl1,
    chainl1Rec: chainl1Rec,
    chainlRec: chainlRec,
    chainr: chainr,
    chainr1: chainr1,
    chainr1Rec: chainr1Rec,
    chainrRec: chainrRec,
    choice: choice,
    endBy: endBy,
    endBy1: endBy1,
    endBy1Rec: endBy1Rec,
    endByRec: endByRec,
    lookAhead: lookAhead,
    many1: many1,
    many1Rec: many1Rec,
    many1Till: many1Till,
    many1TillRec: many1TillRec,
    many1TillRec_: many1TillRec_,
    many1Till_: many1Till_,
    manyTill: manyTill,
    manyTillRec: manyTillRec,
    manyTillRec_: manyTillRec_,
    manyTill_: manyTill_,
    notFollowedBy: notFollowedBy,
    option: option,
    optionMaybe: optionMaybe,
    optional: optional,
    sepBy: sepBy,
    sepBy1: sepBy1,
    sepBy1Rec: sepBy1Rec,
    sepByRec: sepByRec,
    sepEndBy: sepEndBy,
    sepEndBy1: sepEndBy1,
    sepEndBy1Rec: sepEndBy1Rec,
    sepEndByRec: sepEndByRec,
    skipMany: skipMany,
    skipMany1: skipMany1,
    skipMany1Rec: skipMany1Rec,
    skipManyRec: skipManyRec,
    "try": $$try,
    tryRethrow: tryRethrow,
    withErrorMessage: withErrorMessage,
    withLazyErrorMessage: withLazyErrorMessage,
    alt: Control_Plus.alt,
    empty: Control_Plus.empty,
    replicateA: Data_Unfoldable.replicateA,
    replicate1A: Data_Unfoldable1.replicate1A
};
