"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_String_CodePoints = require("../Data.String.CodePoints/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_String_Regex = require("../Data.String.Regex/index.js");
var Data_String_Regex_Flags = require("../Data.String.Regex.Flags/index.js");
var Data_String_Regex_Unsafe = require("../Data.String.Regex.Unsafe/index.js");
var Dodo_Internal = require("../Dodo.Internal/index.js");
var Dodo_Internal_Buffer = require("../Dodo.Internal.Buffer/index.js");

// | Custom printers can be used to render richer documents than just plain
// | text.
// | * `emptyBuffer` - The initial buffer.
// | * `writeText` - Should write a string with the given width to the buffer.
// | * `writeIndent` - Should write indentation with the given width to the buffer.
// | * `writeBreak` - Should write a line break to the buffer.
// | * `enterAnnotation` - Called when entering a new annotated region. Provides the full annotation stack.
// | * `leaveAnnotation` - Called when leaving an annotated region. Provides the full annotation stack.
// | * `flushBuffer` - Called at the end of the document to get the final result.
var Printer = function (x) {
    return x;
};
var Doc = (function () {
    function Doc(value0) {
        this.value0 = value0;
    };
    Doc.create = function (value0) {
        return new Doc(value0);
    };
    return Doc;
})();
var Dedent = (function () {
    function Dedent(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Dedent.create = function (value0) {
        return function (value1) {
            return new Dedent(value0, value1);
        };
    };
    return Dedent;
})();
var LeaveAnnotation = (function () {
    function LeaveAnnotation(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    LeaveAnnotation.create = function (value0) {
        return function (value1) {
            return new LeaveAnnotation(value0, value1);
        };
    };
    return LeaveAnnotation;
})();
var LeaveFlexGroup = (function () {
    function LeaveFlexGroup(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    LeaveFlexGroup.create = function (value0) {
        return function (value1) {
            return new LeaveFlexGroup(value0, value1);
        };
    };
    return LeaveFlexGroup;
})();
var LeaveLocal = (function () {
    function LeaveLocal(value0) {
        this.value0 = value0;
    };
    LeaveLocal.create = function (value0) {
        return new LeaveLocal(value0);
    };
    return LeaveLocal;
})();
var NoFlexGroup = (function () {
    function NoFlexGroup() {

    };
    NoFlexGroup.value = new NoFlexGroup();
    return NoFlexGroup;
})();
var FlexGroupPending = (function () {
    function FlexGroupPending() {

    };
    FlexGroupPending.value = new FlexGroupPending();
    return FlexGroupPending;
})();
var FlexGroupReset = (function () {
    function FlexGroupReset(value0) {
        this.value0 = value0;
    };
    FlexGroupReset.create = function (value0) {
        return new FlexGroupReset(value0);
    };
    return FlexGroupReset;
})();

// | Build a document based on the current layout position.
var withPosition = Dodo_Internal.WithPosition.create;

// | Prints 2-space indents, with a default 80-column page width.
var twoSpaces = {
    pageWidth: 80,
    ribbonRatio: 1.0,
    indentUnit: "  ",
    indentWidth: 2
};

// | The most basic document leaf. This should not contain newlines. If it does
// | your document will look very funny.
var text = function (v) {
    if (v === "") {
        return Dodo_Internal.Empty.value;
    };
    return new Dodo_Internal.Text(Data_String_CodePoints.length(v), v);
};

// | Prints tab indents (4-wide), with a default 120-column page width.
var tabs = {
    pageWidth: 120,
    ribbonRatio: 1.0,
    indentUnit: "\x09",
    indentWidth: 4
};
var storeState = function (stack) {
    return function (v) {
        return {
            position: v.position,
            buffer: v.buffer,
            annotations: v.annotations,
            indentSpaces: v.indentSpaces,
            stack: stack,
            options: v.options
        };
    };
};

// | A singe space character.
var space = text(" ");
var resetState = function (v) {
    return {
        position: v.position,
        buffer: v.buffer,
        annotations: v.annotations,
        indentSpaces: v.indentSpaces,
        flexGroup: NoFlexGroup.value,
        options: v.options
    };
};

// | A plain text printer. Can be used with any document.
var plainText = {
    emptyBuffer: "",
    writeText: function (v) {
        return function (str) {
            return function (buff) {
                return buff + str;
            };
        };
    },
    writeIndent: function (v) {
        return function (str) {
            return function (buff) {
                return buff + str;
            };
        };
    },
    writeBreak: function (buff) {
        return buff + "\x0a";
    },
    enterAnnotation: function (v) {
        return function (v1) {
            return function (buff) {
                return buff;
            };
        };
    },
    leaveAnnotation: function (v) {
        return function (v1) {
            return function (buff) {
                return buff;
            };
        };
    },
    flushBuffer: function (buff) {
        return buff;
    }
};

// | *EXPERIMENTAL:* modifies printing state and options locally for a document.
// | This may change or be removed at any time.
var locally = Dodo_Internal.Local.create;

// | Increases the indentation level by one indent.
var indent = Dodo_Internal.notEmpty(Dodo_Internal.Indent.create);

// | Prints 4-space indents, with a default 120-column page width.
var fourSpaces = {
    pageWidth: 120,
    ribbonRatio: 1.0,
    indentUnit: "    ",
    indentWidth: 4
};

// | Appends a series of documents together with a given append function. This
// | is notable because it ignores empty documents.
var foldWith = function (dictFoldable) {
    return function (f) {
        return Data_Foldable.foldr(dictFoldable)(Dodo_Internal.bothNotEmpty(f))(Data_Monoid.mempty(Dodo_Internal.monoidDoc));
    };
};

// | Appends a series of documents together with a separator in between them.
var foldWithSeparator = function (dictFoldable) {
    return function (separator) {
        return foldWith(dictFoldable)(function (a) {
            return function (b) {
                return Data_Semigroup.append(Dodo_Internal.semigroupDoc)(a)(Data_Semigroup.append(Dodo_Internal.semigroupDoc)(separator)(b));
            };
        });
    };
};

// | Attempts to layout the first document with flex alternatives, falling
// | back to defaults if it doesn't fit the page width. If the flex alternatives
// | are used then the second document will be appended, otherwise the third
// | document will be appended.
var flexSelect = function (doc1) {
    return function (doc2) {
        return function (doc3) {
            if (Dodo_Internal.isEmpty(doc1)) {
                return doc2;
            };
            if (Data_Boolean.otherwise) {
                return new Dodo_Internal.FlexSelect(doc1, doc2, doc3);
            };
            throw new Error("Failed pattern match at Dodo (line 87, column 1 - line 87, column 57): " + [ doc1.constructor.name, doc2.constructor.name, doc3.constructor.name ]);
        };
    };
};

// | Attempts to layout the document with flex alternatives, falling back
// | to defaults if it doesn't fit the page width.
var flexGroup = Dodo_Internal.notEmpty(function (v) {
    if (v instanceof Dodo_Internal.FlexSelect && (Dodo_Internal.isEmpty(v.value1) && Dodo_Internal.isEmpty(v.value2))) {
        return v;
    };
    return new Dodo_Internal.FlexSelect(v, Dodo_Internal.Empty.value, Dodo_Internal.Empty.value);
});

// | Attempts to layout the first document when in a flex group, falling back
// | to the second as a default.
var flexAlt = Dodo_Internal.FlexAlt.create;

// | Uses an opening and closing document, as a well as a separator, to render
// | a series of documents.
// | ```purescript`
// | example = encloseWithSeparator (text "[") (text "]") (",") [ text "one", text "two" ]
// | ```
var encloseWithSeparator = function (dictFoldable) {
    return function (open) {
        return function (close) {
            return function (separator) {
                return function (inner) {
                    return Data_Semigroup.append(Dodo_Internal.semigroupDoc)(open)(Data_Semigroup.append(Dodo_Internal.semigroupDoc)(foldWithSeparator(dictFoldable)(separator)(inner))(close));
                };
            };
        };
    };
};

// | Uses an opening and closing document to wrap another document, falling
// | back when the inner document is empty.
// | ```purescript
// | example = encloseEmptyAlt (text "[ ") (text " ]") (text "[]") mempty
// | ```
var encloseEmptyAlt = function (open) {
    return function (close) {
        return function ($$default) {
            return function (inner) {
                if (Dodo_Internal.isEmpty(inner)) {
                    return $$default;
                };
                if (Data_Boolean.otherwise) {
                    return Data_Semigroup.append(Dodo_Internal.semigroupDoc)(open)(Data_Semigroup.append(Dodo_Internal.semigroupDoc)(inner)(close));
                };
                throw new Error("Failed pattern match at Dodo (line 174, column 1 - line 174, column 71): " + [ open.constructor.name, close.constructor.name, $$default.constructor.name, inner.constructor.name ]);
            };
        };
    };
};

// | Uses an opening and closing document to wrap another document.
// | ```purescript
// | example = enclose (text "(") (text ")") (text "inner")
// | ```
var enclose = function (open) {
    return function (close) {
        return function (inner) {
            return Data_Semigroup.append(Dodo_Internal.semigroupDoc)(open)(Data_Semigroup.append(Dodo_Internal.semigroupDoc)(inner)(close));
        };
    };
};
var calcRibbonWidth = function (v) {
    return function (n) {
        return Data_Ord.max(Data_Ord.ordInt)(0)(Data_Int.ceil(v.ribbonRatio * Data_Int.toNumber(v.pageWidth - n | 0)));
    };
};
var storeOptions = function (prevIndent) {
    return function (localOptions) {
        return function (state) {
            var newOptions = {
                indentUnit: localOptions.indentUnit,
                indentWidth: localOptions.indentWidth,
                pageWidth: localOptions.pageWidth,
                ribbonRatio: localOptions.ribbonRatio
            };
            return {
                position: {
                    line: state.position.line,
                    column: state.position.column,
                    indent: state.position.indent,
                    nextIndent: localOptions.indent,
                    pageWidth: newOptions.pageWidth,
                    ribbonWidth: calcRibbonWidth(newOptions)(prevIndent)
                },
                buffer: state.buffer,
                annotations: state.annotations,
                indentSpaces: localOptions.indentSpaces,
                flexGroup: state.flexGroup,
                options: newOptions
            };
        };
    };
};

// | Prints a documents given a printer and print options.
// |
// | ```purescript
// | print plainText twoSpaces myDoc
// | ```
// |
// | This will use full line-lookahead from the start of a flex group. If it
// | encounters a break or content overflows the page-width, it will layout
// | the group using flex alternative defaults instead.
var print = function (v) {
    return function (opts) {
        var initOptions = {
            pageWidth: opts.pageWidth,
            ribbonRatio: Data_Ord.max(Data_Ord.ordNumber)(0.0)(Data_Ord.min(Data_Ord.ordNumber)(1.0)(opts.ribbonRatio)),
            indentUnit: opts.indentUnit,
            indentWidth: opts.indentWidth
        };
        var initState = {
            position: {
                line: 0,
                column: 0,
                indent: 0,
                nextIndent: 0,
                pageWidth: initOptions.pageWidth,
                ribbonWidth: calcRibbonWidth(initOptions)(0)
            },
            buffer: Dodo_Internal_Buffer["new"](v.emptyBuffer),
            annotations: Data_List_Types.Nil.value,
            indentSpaces: "",
            flexGroup: NoFlexGroup.value,
            options: initOptions
        };
        var go = function ($copy_stack) {
            return function ($copy_state) {
                var $tco_var_stack = $copy_stack;
                var $tco_done = false;
                var $tco_result;
                function $tco_loop(stack, state) {
                    if (stack instanceof Data_List_Types.Nil) {
                        $tco_done = true;
                        return v.flushBuffer(Dodo_Internal_Buffer.get(state.buffer));
                    };
                    if (stack instanceof Data_List_Types.Cons) {
                        if (stack.value0 instanceof Doc) {
                            if (stack.value0.value0 instanceof Dodo_Internal.Append) {
                                $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), stack.value1));
                                $copy_state = state;
                                return;
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.Text) {
                                if (state.position.column === 0 && state.position.indent > 0) {
                                    $tco_var_stack = stack;
                                    $copy_state = {
                                        position: {
                                            line: state.position.line,
                                            column: state.position.indent,
                                            indent: state.position.indent,
                                            nextIndent: state.position.nextIndent,
                                            pageWidth: state.position.pageWidth,
                                            ribbonWidth: state.position.ribbonWidth
                                        },
                                        buffer: Dodo_Internal_Buffer.modify(v.writeIndent(state.position.indent)(state.indentSpaces))(state.buffer),
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces,
                                        flexGroup: state.flexGroup,
                                        options: state.options
                                    };
                                    return;
                                };
                                if ((state.position.column + stack.value0.value0.value0 | 0) <= (state.position.indent + state.position.ribbonWidth | 0)) {
                                    $tco_var_stack = stack.value1;
                                    $copy_state = {
                                        position: {
                                            line: state.position.line,
                                            column: state.position.column + stack.value0.value0.value0 | 0,
                                            indent: state.position.indent,
                                            nextIndent: state.position.nextIndent,
                                            pageWidth: state.position.pageWidth,
                                            ribbonWidth: state.position.ribbonWidth
                                        },
                                        buffer: Dodo_Internal_Buffer.modify(v.writeText(stack.value0.value0.value0)(stack.value0.value0.value1))(state.buffer),
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces,
                                        flexGroup: state.flexGroup,
                                        options: state.options
                                    };
                                    return;
                                };
                                if (Data_Boolean.otherwise) {
                                    if (state.flexGroup instanceof FlexGroupReset) {
                                        $tco_var_stack = state.flexGroup.value0.stack;
                                        $copy_state = resetState(state.flexGroup.value0);
                                        return;
                                    };
                                    $tco_var_stack = stack.value1;
                                    $copy_state = {
                                        position: {
                                            line: state.position.line,
                                            column: state.position.column + stack.value0.value0.value0 | 0,
                                            indent: state.position.indent,
                                            nextIndent: state.position.nextIndent,
                                            pageWidth: state.position.pageWidth,
                                            ribbonWidth: state.position.ribbonWidth
                                        },
                                        buffer: Dodo_Internal_Buffer.modify(v.writeText(stack.value0.value0.value0)(stack.value0.value0.value1))(state.buffer),
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces,
                                        flexGroup: NoFlexGroup.value,
                                        options: state.options
                                    };
                                    return;
                                };
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.Break) {
                                if (state.flexGroup instanceof FlexGroupReset) {
                                    $tco_var_stack = state.flexGroup.value0.stack;
                                    $copy_state = resetState(state.flexGroup.value0);
                                    return;
                                };
                                $tco_var_stack = stack.value1;
                                $copy_state = {
                                    position: {
                                        line: state.position.line + 1 | 0,
                                        column: 0,
                                        indent: state.position.nextIndent,
                                        nextIndent: state.position.nextIndent,
                                        pageWidth: state.position.pageWidth,
                                        ribbonWidth: calcRibbonWidth(state.options)(state.position.nextIndent)
                                    },
                                    buffer: Dodo_Internal_Buffer.modify(v.writeBreak)(state.buffer),
                                    annotations: state.annotations,
                                    indentSpaces: state.indentSpaces,
                                    flexGroup: NoFlexGroup.value,
                                    options: state.options
                                };
                                return;
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.Indent) {
                                if (state.position.column === 0) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), new Data_List_Types.Cons(new Dedent(state.indentSpaces, state.position.nextIndent), stack.value1));
                                    $copy_state = {
                                        position: {
                                            line: state.position.line,
                                            column: state.position.column,
                                            indent: state.position.nextIndent + opts.indentWidth | 0,
                                            nextIndent: state.position.nextIndent + opts.indentWidth | 0,
                                            pageWidth: state.position.pageWidth,
                                            ribbonWidth: calcRibbonWidth(state.options)(state.position.nextIndent + opts.indentWidth | 0)
                                        },
                                        buffer: state.buffer,
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces + opts.indentUnit,
                                        flexGroup: state.flexGroup,
                                        options: state.options
                                    };
                                    return;
                                };
                                if (Data_Boolean.otherwise) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), new Data_List_Types.Cons(new Dedent(state.indentSpaces, state.position.nextIndent), stack.value1));
                                    $copy_state = {
                                        position: {
                                            line: state.position.line,
                                            column: state.position.column,
                                            indent: state.position.indent,
                                            nextIndent: state.position.nextIndent + opts.indentWidth | 0,
                                            pageWidth: state.position.pageWidth,
                                            ribbonWidth: state.position.ribbonWidth
                                        },
                                        buffer: state.buffer,
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces + opts.indentUnit,
                                        flexGroup: state.flexGroup,
                                        options: state.options
                                    };
                                    return;
                                };
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.Align) {
                                if (state.position.column === 0) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), new Data_List_Types.Cons(new Dedent(state.indentSpaces, state.position.nextIndent), stack.value1));
                                    $copy_state = {
                                        position: {
                                            line: state.position.line,
                                            column: state.position.column,
                                            indent: state.position.nextIndent + stack.value0.value0.value0 | 0,
                                            nextIndent: state.position.nextIndent + stack.value0.value0.value0 | 0,
                                            pageWidth: state.position.pageWidth,
                                            ribbonWidth: calcRibbonWidth(state.options)(state.position.nextIndent + stack.value0.value0.value0 | 0)
                                        },
                                        buffer: state.buffer,
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces + Data_Monoid.power(Data_Monoid.monoidString)(" ")(stack.value0.value0.value0),
                                        flexGroup: state.flexGroup,
                                        options: state.options
                                    };
                                    return;
                                };
                                if (Data_Boolean.otherwise) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), new Data_List_Types.Cons(new Dedent(state.indentSpaces, state.position.nextIndent), stack.value1));
                                    $copy_state = {
                                        position: {
                                            line: state.position.line,
                                            column: state.position.column,
                                            indent: state.position.indent,
                                            nextIndent: state.position.nextIndent + stack.value0.value0.value0 | 0,
                                            pageWidth: state.position.pageWidth,
                                            ribbonWidth: state.position.ribbonWidth
                                        },
                                        buffer: state.buffer,
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces + Data_Monoid.power(Data_Monoid.monoidString)(" ")(stack.value0.value0.value0),
                                        flexGroup: state.flexGroup,
                                        options: state.options
                                    };
                                    return;
                                };
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.FlexSelect) {
                                if (state.flexGroup instanceof NoFlexGroup) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), new Data_List_Types.Cons(new LeaveFlexGroup(stack.value0.value0.value1, stack.value0.value0.value2), stack.value1));
                                    $copy_state = {
                                        position: state.position,
                                        buffer: state.buffer,
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces,
                                        flexGroup: FlexGroupPending.value,
                                        options: state.options
                                    };
                                    return;
                                };
                                if (state.flexGroup instanceof FlexGroupPending && state.position.ribbonWidth > 0) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), stack.value1));
                                    $copy_state = {
                                        position: state.position,
                                        buffer: Dodo_Internal_Buffer.branch(state.buffer),
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces,
                                        flexGroup: new FlexGroupReset(storeState(stack)(state)),
                                        options: state.options
                                    };
                                    return;
                                };
                                $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), stack.value1));
                                $copy_state = state;
                                return;
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.FlexAlt) {
                                if (state.flexGroup instanceof FlexGroupReset) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), stack.value1);
                                    $copy_state = state;
                                    return;
                                };
                                if (state.flexGroup instanceof FlexGroupPending && state.position.ribbonWidth > 0) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0), stack.value1);
                                    $copy_state = {
                                        position: state.position,
                                        buffer: Dodo_Internal_Buffer.branch(state.buffer),
                                        annotations: state.annotations,
                                        indentSpaces: state.indentSpaces,
                                        flexGroup: new FlexGroupReset(storeState(new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), stack.value1))(state)),
                                        options: state.options
                                    };
                                    return;
                                };
                                $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), stack.value1);
                                $copy_state = state;
                                return;
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.WithPosition) {
                                if (state.position.column === 0 && state.position.nextIndent > 0) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0({
                                        line: state.position.line,
                                        column: state.position.nextIndent,
                                        indent: state.position.indent,
                                        nextIndent: state.position.nextIndent,
                                        pageWidth: state.position.pageWidth,
                                        ribbonWidth: state.position.ribbonWidth
                                    })), stack.value1);
                                    $copy_state = state;
                                    return;
                                };
                                if (Data_Boolean.otherwise) {
                                    $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value0(state.position)), stack.value1);
                                    $copy_state = state;
                                    return;
                                };
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.Annotate) {
                                $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), new Data_List_Types.Cons(new LeaveAnnotation(stack.value0.value0.value0, state.annotations), stack.value1));
                                $copy_state = {
                                    position: state.position,
                                    buffer: Dodo_Internal_Buffer.modify(v.enterAnnotation(stack.value0.value0.value0)(state.annotations))(state.buffer),
                                    annotations: new Data_List_Types.Cons(stack.value0.value0.value0, state.annotations),
                                    indentSpaces: state.indentSpaces,
                                    flexGroup: state.flexGroup,
                                    options: state.options
                                };
                                return;
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.Local) {
                                var prevOptions = {
                                    indent: state.position.indent,
                                    indentSpaces: state.indentSpaces,
                                    indentUnit: state.options.indentUnit,
                                    indentWidth: state.options.indentWidth,
                                    pageWidth: state.options.pageWidth,
                                    ribbonRatio: state.options.ribbonRatio
                                };
                                var localOptions = stack.value0.value0.value0(prevOptions);
                                $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0.value1), new Data_List_Types.Cons(new LeaveLocal(prevOptions), stack.value1));
                                $copy_state = storeOptions(state.position.indent)(localOptions)(state);
                                return;
                            };
                            if (stack.value0.value0 instanceof Dodo_Internal.Empty) {
                                $tco_var_stack = stack.value1;
                                $copy_state = state;
                                return;
                            };
                            throw new Error("Failed pattern match at Dodo (line 357, column 18 - line 469, column 23): " + [ stack.value0.value0.constructor.name ]);
                        };
                        if (stack.value0 instanceof LeaveFlexGroup) {
                            if (state.flexGroup instanceof NoFlexGroup) {
                                $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value1), stack.value1);
                                $copy_state = {
                                    position: state.position,
                                    buffer: Dodo_Internal_Buffer.commit(state.buffer),
                                    annotations: state.annotations,
                                    indentSpaces: state.indentSpaces,
                                    flexGroup: state.flexGroup,
                                    options: state.options
                                };
                                return;
                            };
                            $tco_var_stack = new Data_List_Types.Cons(new Doc(stack.value0.value0), stack.value1);
                            $copy_state = {
                                position: state.position,
                                buffer: Dodo_Internal_Buffer.commit(state.buffer),
                                annotations: state.annotations,
                                indentSpaces: state.indentSpaces,
                                flexGroup: NoFlexGroup.value,
                                options: state.options
                            };
                            return;
                        };
                        if (stack.value0 instanceof Dedent) {
                            $tco_var_stack = stack.value1;
                            $copy_state = {
                                position: {
                                    line: state.position.line,
                                    column: state.position.column,
                                    indent: state.position.indent,
                                    nextIndent: stack.value0.value1,
                                    pageWidth: state.position.pageWidth,
                                    ribbonWidth: state.position.ribbonWidth
                                },
                                buffer: state.buffer,
                                annotations: state.annotations,
                                indentSpaces: stack.value0.value0,
                                flexGroup: state.flexGroup,
                                options: state.options
                            };
                            return;
                        };
                        if (stack.value0 instanceof LeaveAnnotation) {
                            $tco_var_stack = stack.value1;
                            $copy_state = {
                                position: state.position,
                                buffer: Dodo_Internal_Buffer.modify(v.leaveAnnotation(stack.value0.value0)(stack.value0.value1))(state.buffer),
                                annotations: stack.value0.value1,
                                indentSpaces: state.indentSpaces,
                                flexGroup: state.flexGroup,
                                options: state.options
                            };
                            return;
                        };
                        if (stack.value0 instanceof LeaveLocal) {
                            $tco_var_stack = stack.value1;
                            $copy_state = storeOptions(state.position.indent)(stack.value0.value0)(state);
                            return;
                        };
                        throw new Error("Failed pattern match at Dodo (line 356, column 18 - line 491, column 70): " + [ stack.value0.constructor.name ]);
                    };
                    throw new Error("Failed pattern match at Dodo (line 353, column 20 - line 491, column 70): " + [ stack.constructor.name ]);
                };
                while (!$tco_done) {
                    $tco_result = $tco_loop($tco_var_stack, $copy_state);
                };
                return $tco_result;
            };
        };
        var $108 = Data_Function.flip(go)(initState);
        var $109 = Control_Applicative.pure(Data_List_Types.applicativeList);
        return function ($110) {
            return $108($109(Doc.create($110)));
        };
    };
};

// | Inserts a hard line break.
var $$break = Dodo_Internal.Break.value;

// | Inserts nothing when in a flex group, otherwise inserts a break.
var softBreak = flexAlt(Data_Monoid.mempty(Dodo_Internal.monoidDoc))($$break);

// | Inserts a space when in a flex group, otherwise inserts a break.
var spaceBreak = flexAlt(space)($$break);

// | Appends two documents with a space between them, falling back to a
// | break if that does not fit.
var appendSpaceBreak = Dodo_Internal.bothNotEmpty(function (a) {
    return function (b) {
        return Data_Semigroup.append(Dodo_Internal.semigroupDoc)(a)(flexGroup(Data_Semigroup.append(Dodo_Internal.semigroupDoc)(spaceBreak)(b)));
    };
});

// | Appends documents with a space-break in between them.
var paragraph = function (dictFoldable) {
    return Data_Foldable.foldl(dictFoldable)(appendSpaceBreak)(Dodo_Internal.Empty.value);
};

// | Constructs a wrapping paragraph from a blob of text. Ignores newlines and
// | multiple spaces.
var textParagraph = (function () {
    var spaceRegex = Data_String_Regex_Unsafe.unsafeRegex("[\\s\\n]+")(Data_String_Regex_Flags.global);
    var $111 = paragraph(Data_Foldable.foldableArray);
    var $112 = Data_Functor.map(Data_Functor.functorArray)(text);
    var $113 = Data_String_Regex.split(spaceRegex);
    return function ($114) {
        return $111($112($113(Data_String_Common.trim($114))));
    };
})();

// | Appends two documents with a space between them.
var appendSpace = Dodo_Internal.bothNotEmpty(function (a) {
    return function (b) {
        return Data_Semigroup.append(Dodo_Internal.semigroupDoc)(a)(Data_Semigroup.append(Dodo_Internal.semigroupDoc)(space)(b));
    };
});

// | Appends documents with a space in between them.
var words = function (dictFoldable) {
    return Data_Foldable.foldr(dictFoldable)(appendSpace)(Dodo_Internal.Empty.value);
};

// | Appends two documents with a break between them.
var appendBreak = Dodo_Internal.bothNotEmpty(function (a) {
    return function (b) {
        return Data_Semigroup.append(Dodo_Internal.semigroupDoc)(a)(Data_Semigroup.append(Dodo_Internal.semigroupDoc)($$break)(b));
    };
});

// | Appends documents with a break in between them.
var lines = function (dictFoldable) {
    return Data_Foldable.foldr(dictFoldable)(appendBreak)(Dodo_Internal.Empty.value);
};

// | Adds an annotation to a document. Printers can interpret annotations to style
// | their output, eg. ANSI colors.
var annotate = function ($115) {
    return Dodo_Internal.notEmpty(Dodo_Internal.Annotate.create($115));
};

// | Increases the indentation level by the number of spaces (for alignment purposes).
var align = function (n) {
    return function (doc) {
        if (n > 0) {
            return Dodo_Internal.notEmpty(Dodo_Internal.Align.create(n))(doc);
        };
        if (Data_Boolean.otherwise) {
            return doc;
        };
        throw new Error("Failed pattern match at Dodo (line 62, column 1 - line 62, column 41): " + [ n.constructor.name, doc.constructor.name ]);
    };
};

// | Increases the indentation level so that it aligns to the current column.
var alignCurrentColumn = Dodo_Internal.notEmpty(function (doc) {
    return withPosition(function (pos) {
        return align(pos.column - pos.nextIndent | 0)(doc);
    });
});
module.exports = {
    indent: indent,
    align: align,
    alignCurrentColumn: alignCurrentColumn,
    annotate: annotate,
    withPosition: withPosition,
    text: text,
    "break": $$break,
    spaceBreak: spaceBreak,
    softBreak: softBreak,
    space: space,
    lines: lines,
    words: words,
    appendBreak: appendBreak,
    appendSpace: appendSpace,
    appendSpaceBreak: appendSpaceBreak,
    flexAlt: flexAlt,
    flexGroup: flexGroup,
    flexSelect: flexSelect,
    paragraph: paragraph,
    textParagraph: textParagraph,
    enclose: enclose,
    encloseEmptyAlt: encloseEmptyAlt,
    encloseWithSeparator: encloseWithSeparator,
    foldWithSeparator: foldWithSeparator,
    foldWith: foldWith,
    locally: locally,
    print: print,
    Printer: Printer,
    plainText: plainText,
    twoSpaces: twoSpaces,
    fourSpaces: fourSpaces,
    tabs: tabs,
    bothNotEmpty: Dodo_Internal.bothNotEmpty,
    isEmpty: Dodo_Internal.isEmpty,
    notEmpty: Dodo_Internal.notEmpty
};
