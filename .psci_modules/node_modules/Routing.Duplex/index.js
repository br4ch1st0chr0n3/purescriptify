"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Category = require("../Control.Category/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Symbol = require("../Data.Symbol/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Record = require("../Record/index.js");
var Routing_Duplex_Parser = require("../Routing.Duplex.Parser/index.js");
var Routing_Duplex_Printer = require("../Routing.Duplex.Printer/index.js");
var Type_Proxy = require("../Type.Proxy/index.js");

// | The core abstraction of this library. The values of this type can be used both for parsing
// | values of type `o` from `String` as well as printing values of type `i` into `String`.
// |
// | For most purposes, you'll likely want `RouterDuplex'` which uses the same
// | type for both parameters.
var RouteDuplex = (function () {
    function RouteDuplex(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    RouteDuplex.create = function (value0) {
        return function (value1) {
            return new RouteDuplex(value0, value1);
        };
    };
    return RouteDuplex;
})();

// | Similar to `prefix`. Strips (when parsing) or adds (when printing) a given
// | string segment from the end of the path. The same precautions for `prefix` apply here.
var suffix = function (v) {
    return function (s) {
        return new RouteDuplex(function (a) {
            return Data_Semigroup.append(Routing_Duplex_Printer.semigroupRoutePrinter)(v.value0(a))(Routing_Duplex_Printer.put(s));
        }, Control_Apply.applyFirst(Routing_Duplex_Parser.applyRouteParser)(v.value1)(Routing_Duplex_Parser.prefix(s)(Control_Applicative.pure(Routing_Duplex_Parser.applicativeRouteParser)(Data_Unit.unit))));
    };
};

// | This does nothing (internally it's defined as identity).
// | It can be used to restrict a type parameter of a polymorphic `RouteDuplex' a` to `String`.
var string = Control_Category.identity(Control_Category.categoryFn);

// | Consumes or prints a single path segment.
// | **Note:** [URI encoding and decoding](https://en.wikipedia.org/wiki/Percent-encoding) is done automatically.
// |
// | ```purescript
// | parse segment "abc"         == Right "abc"
// | parse segment "abc%20def"   == Right "abc def" -- automatic decoding of uri components
// | parse segment "abc/def"     == Right "abc"
// | parse segment "/abc"        == Right "" -- the empty string before the first '/'
// | parse (root segment) "/abc" == Right "abc"
// |
// | print segment "hello there" == "hello%20there"
// | print segment "" == "/"
// | ```
var segment = new RouteDuplex(Routing_Duplex_Printer.put, Routing_Duplex_Parser.take);

// | Consumes or prints all the remaining segments.
// |
// |```purescript
// | parse rest "" == Right []
// | parse (path "a/b" rest) "a/b/c/d" == Right ["c", "d"]
// |
// | print rest ["a", "b"] == "a/b"
// |```
var rest = new RouteDuplex(Data_Foldable.foldMap(Data_Foldable.foldableArray)(Routing_Duplex_Printer.monoidRoutePRinter)(Routing_Duplex_Printer.put), Routing_Duplex_Parser.rest);

// | Combined with `prop` or `:=`, builds a Record where the order of
// | parsing and printing matters.
// |
// | ```purescript
// | date =
// |   record
// |     # prop (Proxy :: _ "year") (int segment)
// |     # prop (Proxy :: _ "month") (int segment)
// |     # prop (Proxy :: _ "day") (int segment)
// |
// | parse (path "blog" date) "blog/2019/1/2" ==
// |   Right { year: 2019, month: 1, day: 2 }
// | ````
var record = new RouteDuplex(Data_Monoid.mempty(Data_Monoid.monoidFn(Routing_Duplex_Printer.monoidRoutePRinter)), Control_Applicative.pure(Routing_Duplex_Parser.applicativeRouteParser)({}));

// | See `record`.
var prop = function (dictIsSymbol) {
    return function () {
        return function () {
            return function () {
                return function (sym) {
                    return function (v) {
                        return function (v1) {
                            return new RouteDuplex(function (r) {
                                return Data_Semigroup.append(Routing_Duplex_Printer.semigroupRoutePrinter)(v1.value0(r))(v.value0(Record.get(dictIsSymbol)()(sym)(r)));
                            }, Control_Apply.apply(Routing_Duplex_Parser.applyRouteParser)(Data_Functor.map(Routing_Duplex_Parser.functorRouteParser)(Data_Function.flip(Record.insert(dictIsSymbol)()()(sym)))(v1.value1))(v.value1));
                        };
                    };
                };
            };
        };
    };
};
var profunctorRouteDuplex = {
    dimap: function (f) {
        return function (g) {
            return function (v) {
                return new RouteDuplex(function ($95) {
                    return v.value0(f($95));
                }, Data_Functor.map(Routing_Duplex_Parser.functorRouteParser)(g)(v.value1));
            };
        };
    }
};

// | Renders a value of type `i` into a String representation of URI path,
// | query and fragment (hash).
var print = function (v) {
    return function ($96) {
        return Routing_Duplex_Printer.run(v.value0($96));
    };
};

// | Strips (when parsing) or adds (when printing) a given string segment of the
// | path. **Note:** this combinator only deals with a single segment.
// | If you pass it a string containing '/' it will [percent encode](https://en.wikipedia.org/wiki/Percent-encoding) it and treat it as single segment.
// | E.g. `prefix "/api/v1"` will attempt to match single segment `"%2Fapi%2Fv1"` which is probably not what you want.
// | See `path` if you want to deal with prefixes consisting of multiple segments.
// |
// |```purescript
// | parse (prefix "api" segment) "api/a" == Right "a"
// |
// | parse (prefix "/api/v1" segment)) "/api/v1/a" == Left (Expected "/api/v1" "")
// |
// | -- contrast with `path`
// | parse (path "/api/v1" segment)) "/api/v1/a" == Right "a"
// |```
var prefix = function (s) {
    return function (v) {
        return new RouteDuplex(function (a) {
            return Data_Semigroup.append(Routing_Duplex_Printer.semigroupRoutePrinter)(Routing_Duplex_Printer.put(s))(v.value0(a));
        }, Routing_Duplex_Parser.prefix(s)(v.value1));
    };
};

// | Strips (when parsing) or adds (when printing) a given String prefix,
// | potentially consisting of multiple path segments. Constrast this with `prefix`,
// | which only deals with single segment.
// |
// |```purescript
// | parse (path "/api/v1" segment) "/api/v1/a" == Right "a"
// | parse (path "/api/v1" segment) "/api/v2/a" == Left (Expected "v1" "v2")
// |```
var path = (function () {
    var $97 = Data_Function.flip(Data_Foldable.foldr(Data_Foldable.foldableArray)(prefix));
    var $98 = Data_String_Common.split("/");
    return function ($99) {
        return $97($98($99));
    };
})();

// | Modifies a given codec to require a prefix of '/'.
// | You can think of it as stripping and adding the '/' at the beginning of path,
// | failing if it's not there.
// |
// |```purescript
// | parse (root segment) "/abc" == Right "abc"
// | parse (root segment) "abc" == Left (Expected "" "abc")
// |
// | print (root segment) "abc" == "/abc"
// |```
var root = path("");

// | Uses a given codec to parse a value of type `o` out of String representing
// | the path, query and fragment (hash) of a URI (see
// | [URI - generic syntax](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Generic_syntax))
// | or produce a `RouteError` if parsing fails.
var parse = function (v) {
    return Routing_Duplex_Parser.run(v.value1);
};

// | Builds a `RouteDuplex` from a record of query parameter parsers/printers, where
// | each property corresponds to a query parameter with the same name.
// |
// | ```purescript
// | search =
// |   params
// |     { page: int
// |     , filter: optional <<< string
// |     }
// |
// | parse search "?page=3&filter=Galaxy%20Quest" ==
// |   Right { page: 3, filter: Just "Galaxy Quest" }
// | ```
var params = function (dict) {
    return dict.params;
};

// | `param name` consumes or prints a query parameter with the given `name`.
// | Parsing will fail if the parameter is not there.
// |
// |```purescript
// | parse (param "search") "?search=keyword" == Right "keyword"
// | parse (param "search") "/"               == Left (MissingParam "search")
// | parse (optional (param "search")) "/"    == Right Nothing
// |```
var param = function (p) {
    return new RouteDuplex(Routing_Duplex_Printer.param(p), Routing_Duplex_Parser.param(p));
};

// | Augments the behavior of a given codec by making it return `Nothing` if parsing
// | fails, or `Just value` if it succeeds.
// |
// |```purescript
// | parse (optional segment) "a"        == Right (Just "a")
// | parse (optional segment) ""         == Right Nothing
// |
// | print (optional segment) (Just "a") == "a"
// | print (optional segment) Nothing    == ""
// |```
var optional = function (v) {
    return new RouteDuplex(Data_Foldable.foldMap(Data_Foldable.foldableMaybe)(Routing_Duplex_Printer.monoidRoutePRinter)(v.value0), Routing_Duplex_Parser.optional(v.value1));
};

// | Repeatedly applies a given codec to parse one or more values from path segments.
// | Parsing will fail if no segment can be parsed.
// |
// |```purescript
// | parse (many1 (int segment)) "1/2/3/x" == Right [1,2,3]
// | parse (many1 (int segment)) "x",      == Left (Expected "Int" "x") :: Either RouteError (Array Int)
// |```
var many1 = function (dictFoldable) {
    return function (dictAlt) {
        return function (dictApplicative) {
            return function (v) {
                return new RouteDuplex(Data_Foldable.foldMap(dictFoldable)(Routing_Duplex_Printer.monoidRoutePRinter)(v.value0), Routing_Duplex_Parser.many1(dictAlt)(dictApplicative)(v.value1));
            };
        };
    };
};

// | Similar to `many1`, except also succeeds when no values can be parsed.
// |
// |```purescript
// | parse (many (int segment)) "1/2/3/x" == Right [1,2,3]
// | parse (many (int segment)) "x",      == Right []
// |```
var many = function (dictFoldable) {
    return function (dictAlternative) {
        return function (v) {
            return new RouteDuplex(Data_Foldable.foldMap(dictFoldable)(Routing_Duplex_Printer.monoidRoutePRinter)(v.value0), Routing_Duplex_Parser.many(dictAlternative)(v.value1));
        };
    };
};
var functorRouteDuplex = {
    map: function (f) {
        return function (m) {
            return new RouteDuplex(m.value0, Data_Functor.map(Routing_Duplex_Parser.functorRouteParser)(f)(m.value1));
        };
    }
};

// | Consumes or prints a query flag (i.e. parameter without value).
// | **Note:** that this combinator ignores the value of the parameter. It only cares about its presence/absence.
// | Presence is interpreted as `true`, absence as `false`.
// |
// |```purescript
// | parse (flag (param "x")) "?x"        == Right true
// | parse (flag (param "x")) "?x=true",  == Right true
// | parse (flag (param "x")) "?x=false", == Right true -- value is ignored, what matters is presence of the parameter x
// | parse (flag (param "x")) "?y",       == Right false
// |```
var flag = function (v) {
    var enc$prime = function (v1) {
        if (v1) {
            return v.value0("");
        };
        return Data_Monoid.mempty(Routing_Duplex_Printer.monoidRoutePRinter);
    };
    var dec$prime = Routing_Duplex_Parser["default"](false)(Data_Functor.voidLeft(Routing_Duplex_Parser.functorRouteParser)(v.value1)(true));
    return new RouteDuplex(enc$prime, dec$prime);
};

// | `end codec` will only suceed if `codec` succeeds and there are no
// | additional path segments remaining to be processed.
// |
// |```purescript
// | parse (end segment) "abc" == Right "abc"
// | parse (end segment) "abc/def" == Left (ExpectedEndOfPath "def")
// |```
var end = function (v) {
    return new RouteDuplex(v.value0, Control_Apply.applyFirst(Routing_Duplex_Parser.applyRouteParser)(v.value1)(Routing_Duplex_Parser.end));
};

// | Sets a default value which will be returned when parsing fails.
// | Does not influence printing in any way.
// |
// |```purescript
// | parse (default 0 $ int segment) "1" == Right 1
// | parse (default 0 $ int segment) "x" == Right 0
// |```
var $$default = function (d) {
    return function (v) {
        return new RouteDuplex(v.value0, Routing_Duplex_Parser["default"](d)(v.value1));
    };
};
var buildParamsNil = {
    buildParams: function (v) {
        return function (v1) {
            return Control_Category.identity(Control_Category.categoryFn);
        };
    }
};
var buildParams = function (dict) {
    return dict.buildParams;
};
var buildParamsCons = function (dictIsSymbol) {
    return function () {
        return function () {
            return function () {
                return function () {
                    return function (dictRouteDuplexBuildParams) {
                        return {
                            buildParams: function (v) {
                                return function (r) {
                                    return function (prev) {
                                        return buildParams(dictRouteDuplexBuildParams)(Type_Proxy["Proxy"].value)(r)(prop(dictIsSymbol)()()()(Type_Proxy["Proxy"].value)(Record.get(dictIsSymbol)()(Type_Proxy["Proxy"].value)(r)(param(Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy["Proxy"].value))))(prev));
                                    };
                                };
                            }
                        };
                    };
                };
            };
        };
    };
};
var routeDuplexParams = function () {
    return function (dictRouteDuplexBuildParams) {
        return {
            params: function (r) {
                return buildParams(dictRouteDuplexBuildParams)(Type_Proxy["Proxy"].value)(r)(record);
            }
        };
    };
};

// | Builds a codec for a custom type out of printer and parser functions.
// |
// |```purescript
// | data Sort = Asc | Desc
// |
// | sortToString :: Sort -> String
// | sortToString = case _ of
// |   Asc -> "asc"
// |   Desc -> "desc"
// |
// | sortFromString :: String -> Either String Sort
// | sortFromString = case _ of
// |   "asc" -> Right Asc
// |   "desc" -> Right Desc
// |   val -> Left $ "Not a sort: " <> val
// |
// | sort :: RouteDuplex' String -> RouteDuplex' Sort
// | sort = as sortToString sortFromString
// |```
var as = function (f) {
    return function (g) {
        return function (v) {
            return new RouteDuplex(function ($100) {
                return v.value0(f($100));
            }, Routing_Duplex_Parser.as(Control_Category.identity(Control_Category.categoryFn))(g)(v.value1));
        };
    };
};

// | Refines a codec of Strings to Booleans, where `true` and `false` are the
// | strings `"true"` and `"false"`, and other strings are rejected.
// |
// | ```purescript
// | parse (boolean segment) "true"  == Right true
// | parse (boolean segment) "x"     == Left (Expected "Boolean" "x")
// |
// | print (boolean segment) true    == "true"
// | ```
var $$boolean = as(Data_Show.show(Data_Show.showBoolean))(Routing_Duplex_Parser["boolean"]);

// | Refines a codec of Strings to Ints.
// |
// | ```purescript
// | parse (int segment) "1"  == Right 1
// | parse (int segment) "x"  == Left (Expected "Int" "x")
// |
// | print (int segment) 1    == "1"
// | ```
var $$int = as(Data_Show.show(Data_Show.showInt))(Routing_Duplex_Parser["int"]);
var applyRouteDuplex = {
    apply: function (v) {
        return function (v1) {
            return new RouteDuplex(Control_Apply.apply(Control_Apply.applyFn)(Data_Functor.map(Data_Functor.functorFn)(Data_Semigroup.append(Routing_Duplex_Printer.semigroupRoutePrinter))(v.value0))(v1.value0), Control_Apply.apply(Routing_Duplex_Parser.applyRouteParser)(v.value1)(v1.value1));
        };
    },
    Functor0: function () {
        return functorRouteDuplex;
    }
};
var applicativeRouteDuplex = {
    pure: (function () {
        var $101 = RouteDuplex.create(Data_Function["const"](Data_Monoid.mempty(Routing_Duplex_Printer.monoidRoutePRinter)));
        var $102 = Control_Applicative.pure(Routing_Duplex_Parser.applicativeRouteParser);
        return function ($103) {
            return $101($102($103));
        };
    })(),
    Apply0: function () {
        return applyRouteDuplex;
    }
};
module.exports = {
    RouteDuplex: RouteDuplex,
    parse: parse,
    print: print,
    prefix: prefix,
    suffix: suffix,
    path: path,
    root: root,
    end: end,
    segment: segment,
    param: param,
    flag: flag,
    many1: many1,
    many: many,
    rest: rest,
    "default": $$default,
    optional: optional,
    as: as,
    "int": $$int,
    "boolean": $$boolean,
    string: string,
    record: record,
    prop: prop,
    params: params,
    buildParams: buildParams,
    functorRouteDuplex: functorRouteDuplex,
    applyRouteDuplex: applyRouteDuplex,
    applicativeRouteDuplex: applicativeRouteDuplex,
    profunctorRouteDuplex: profunctorRouteDuplex,
    routeDuplexParams: routeDuplexParams,
    buildParamsCons: buildParamsCons,
    buildParamsNil: buildParamsNil
};
