"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Monad_Error_Class = require("../Control.Monad.Error.Class/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Function_Uncurried = require("../Data.Function.Uncurried/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Effect = require("../Effect/index.js");
var Effect_Aff = require("../Effect.Aff/index.js");
var Effect_Class = require("../Effect.Class/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var Effect_Unsafe = require("../Effect.Unsafe/index.js");
var React_Basic_Hooks = require("../React.Basic.Hooks/index.js");
var React_Basic_Hooks_Internal = require("../React.Basic.Hooks.Internal/index.js");
var Type_Equality = require("../Type.Equality/index.js");
var UseAff = function (x) {
    return x;
};
var AffReducer = function (x) {
    return x;
};
var UseAffReducer = function (x) {
    return x;
};

// | Run a wrapped `Reducer` function as a normal function (like `runFn2`).
// | Useful for testing, simulating actions, or building more complicated
// | hooks on top of `useReducer`
var runAffReducer = function (v) {
    return Data_Function_Uncurried.runFn2(v);
};
var ntUseAffReducer = {
    Coercible0: function () {
        return undefined;
    }
};

// | Provide an initial state and a reducer function. This is a more powerful
// | version of `useReducer`, where a state change can additionally queue
// | asynchronous operations. The results of those operations must be  mapped
// | into the reducer's `action` type. This is essentially the Elm architecture.
// |
// | Generally, I recommend `useAff` paired with tools like `useResetToken` over
// | `useAffReducer` as there are many ways `useAffReducer` can result in race
// | conditions. `useAff` with proper dependency management will handle previous
// | request cancellation and ensure your `Aff` result is always in sync with
// | the provided `deps`, for example. To accomplish the same thing with
// | `useAffReducer` would require tracking `Fiber`s manually in your state
// | somehow.. :c
// |
// | That said, `useAffReducer` can still be helpful when converting from the
// | current `React.Basic` (non-hooks) API or for those used to Elm.
// |
// | *Note: Aff failures are thrown. If you need to capture an error state, be
// |   sure to capture it in your action type!*
var useAffReducer = function (initialState) {
    return function (affReducer) {
        return React_Basic_Hooks_Internal.coerceHook()(React_Basic_Hooks_Internal.bind(React_Basic_Hooks_Internal.ixBindRender)(React_Basic_Hooks.useMemo(React_Basic_Hooks.eqUnsafeReference)(affReducer)(function (v) {
            return Effect_Unsafe.unsafePerformEffect(React_Basic_Hooks.mkReducer(function (v1) {
                return runAffReducer(affReducer)(v1.state);
            }));
        }))(function (reducer$prime) {
            return React_Basic_Hooks_Internal.bind(React_Basic_Hooks_Internal.ixBindRender)(React_Basic_Hooks.useReducer({
                state: initialState,
                effects: [  ]
            })(reducer$prime))(function (v) {
                return React_Basic_Hooks_Internal.discard(React_Basic_Hooks_Internal.ixBindRender)(React_Basic_Hooks.useEffect(React_Basic_Hooks.eqUnsafeReference)(v.value0.effects)(function __do() {
                    Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(v.value0.effects)(function (aff) {
                        return Effect_Aff.launchAff_(Control_Bind.bind(Effect_Aff.bindAff)(aff)(function (actions) {
                            return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(actions)(v.value1));
                        }));
                    })();
                    return Data_Monoid.mempty(Effect.monoidEffect(Effect.monoidEffect(Data_Monoid.monoidUnit)))();
                }))(function () {
                    return Control_Applicative.pure(React_Basic_Hooks_Internal.applicativeRender(Type_Equality.refl))(new Data_Tuple.Tuple(v.value0.state, v.value1));
                });
            });
        }));
    };
};
var ntUseAff = {
    Coercible0: function () {
        return undefined;
    }
};

// | `useAff` is used for asynchronous effects or `Aff`. The asynchronous effect
// | is re-run whenever the deps change. If another `Aff` runs when the deps
// | change before the previous async resolves, it will cancel the previous
// | in-flight effect.
// |
// | *Note: This hook requires parent components to handle error states! Don't
// |   forget to implement a React error boundary or avoid `Aff` errors entirely
// |   by incorporating them into your result type!*
var useAff = function (dictEq) {
    return function (deps) {
        return function (aff) {
            return React_Basic_Hooks_Internal.coerceHook()(React_Basic_Hooks_Internal.bind(React_Basic_Hooks_Internal.ixBindRender)(React_Basic_Hooks.useState(Data_Maybe.Nothing.value))(function (v) {
                return React_Basic_Hooks_Internal.discard(React_Basic_Hooks_Internal.ixBindRender)(React_Basic_Hooks.useEffect(dictEq)(deps)(function __do() {
                    v.value1(Data_Function["const"](Data_Maybe.Nothing.value))();
                    var fiber = Effect_Aff.launchAff(Control_Bind.bind(Effect_Aff.bindAff)(Control_Monad_Error_Class["try"](Effect_Aff.monadErrorAff)(aff))(function (r) {
                        return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(v.value1(function (v1) {
                            return new Data_Maybe.Just(r);
                        }));
                    }))();
                    return Effect_Aff.launchAff_(Effect_Aff.killFiber(Effect_Exception.error("Stale request cancelled"))(fiber));
                }))(function () {
                    return React_Basic_Hooks_Internal.unsafeRenderEffect((function () {
                        if (v.value0 instanceof Data_Maybe.Just && v.value0.value0 instanceof Data_Either.Left) {
                            return Control_Monad_Error_Class.throwError(Control_Monad_Error_Class.monadThrowEffect)(v.value0.value0.value0);
                        };
                        if (v.value0 instanceof Data_Maybe.Just && v.value0.value0 instanceof Data_Either.Right) {
                            return Control_Applicative.pure(Effect.applicativeEffect)(new Data_Maybe.Just(v.value0.value0.value0));
                        };
                        if (v.value0 instanceof Data_Maybe.Nothing) {
                            return Control_Applicative.pure(Effect.applicativeEffect)(Data_Maybe.Nothing.value);
                        };
                        throw new Error("Failed pattern match at React.Basic.Hooks.Aff (line 53, column 24 - line 56, column 30): " + [ v.value0.constructor.name ]);
                    })());
                });
            }));
        };
    };
};
var noEffects = function (state) {
    return {
        state: state,
        effects: [  ]
    };
};
var mkAffReducer = (function () {
    var $23 = Control_Applicative.pure(Effect.applicativeEffect);
    return function ($24) {
        return $23(AffReducer(Data_Function_Uncurried.mkFn2($24)));
    };
})();
module.exports = {
    useAff: useAff,
    UseAff: UseAff,
    useAffReducer: useAffReducer,
    mkAffReducer: mkAffReducer,
    runAffReducer: runAffReducer,
    noEffects: noEffects,
    UseAffReducer: UseAffReducer,
    ntUseAff: ntUseAff,
    ntUseAffReducer: ntUseAffReducer
};
