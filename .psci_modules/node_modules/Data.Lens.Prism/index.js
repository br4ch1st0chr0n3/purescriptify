
// | Prisms are used for selecting cases of a type, most often a sum
// | type. Consider this:
// |
// | ```purescript
// | data Fill -- think of a paint program filling a shape
// |   = NoFill
// |   | Solid Color
// |   | ...
// | ```
// |
// | A prism that focuses on `Solid` fills could be written like this:
// |
// | ```purescript
// | solidFocus :: Prism' Fill Color
// | solidFocus = prism' Solid case _ of
// |   Solid color -> Just color
// |   _ -> Nothing
// | ```
// |
// | ... and used like this:
// |
// | ```purescript
// | preview solidFocus (Solid Color.white) == Just Color.white
// | preview solidFocus NoFill == Nothing
// |
// | is solidFocus (Solid Color.white) == true
// | ```
// |
// | `review` can be used to go from a `Color` to a `Fill`:
// |
// | ```purescript
// | review solidFocus Color.white == Solid Color.white
// | ```
// | 
// | For more information, see `PrismsForSumTypes.purs` in the
// | `examples/src` directory.
// |
// | ---------------
// |
// | A well-behaved `Prism` will follow these laws:
// |
// | **review-preview**: `preview` retrieves what `review` creates. Equationally:
// |   
// | ```purescript
// | review prism >>> preview prism ≡ Just
// | ```
// |
// | An example:
// | 
// | ```purescript
// | Color.white # review solidFocus # preview solidFocus
// |   == Just Color.white
// | ```
// | 
// | **preview-review**: If `preview` retrieves something, `review` can create
// | the original from that something. Equationally:
// | 
// | ```purescript
// | if preview prism s ≡ Just a then review prism a ≡ s
// | ```
// |
// | An example:
// |
// | ```purescript
// | Solid Color.white # preview solidFocus <#> review solidFocus
// |   == Solid Color.white
// | ```
"use strict";
var Control_Alternative = require("../Control.Alternative/index.js");
var Control_Category = require("../Control.Category/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Lens_Internal_Market = require("../Data.Lens.Internal.Market/index.js");
var Data_Lens_Internal_Tagged = require("../Data.Lens.Internal.Tagged/index.js");
var Data_Lens_Types = require("../Data.Lens.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Profunctor = require("../Data.Profunctor/index.js");
var Data_Profunctor_Choice = require("../Data.Profunctor.Choice/index.js");
var withPrism = function (l) {
    return function (f) {
        var v = l(new Data_Lens_Internal_Market.Market(Control_Category.identity(Control_Category.categoryFn), Data_Either.Right.create));
        return f(v.value0)(v.value1);
    };
};

// | Create the "whole" corresponding to a specific "part":
// |
// | ```purescript
// | review solidFocus Color.white == Solid Color.white
// | ```
var review = Data_Newtype.under()()(Data_Lens_Internal_Tagged.Tagged);

// | Create a `Prism` from a constructor and a matcher function that
// | produces an `Either`:
// | 
// | ```purescript
// | solidFocus :: Prism' Fill Color
// | solidFocus = prism Solid case _ of
// |   Solid color -> Right color
// |   anotherCase -> Left anotherCase
// | ```
// |
// | _Note_: The matcher function returns a result wrapped in `Either t`
// | to allow for type-changing prisms in the case where the input does
// | not match.
var prism = function (to) {
    return function (fro) {
        return function (dictChoice) {
            return function (pab) {
                return Data_Profunctor.dimap(dictChoice.Profunctor0())(fro)(Data_Either.either(Control_Category.identity(Control_Category.categoryFn))(Control_Category.identity(Control_Category.categoryFn)))(Data_Profunctor_Choice.right(dictChoice)(Data_Profunctor.rmap(dictChoice.Profunctor0())(to)(pab)));
            };
        };
    };
};

// | Create a `Prism` from a constructor and a matcher function that
// | produces a `Maybe`:
// | 
// | ```purescript
// | solidFocus :: Prism' Fill Color
// | solidFocus = prism' Solid case _ of
// |   Solid color -> Just color
// |   _ -> Nothing
// | ```
var prism$prime = function (to) {
    return function (fro) {
        return function (dictChoice) {
            return prism(to)(function (s) {
                return Data_Maybe.maybe(new Data_Either.Left(s))(Data_Either.Right.create)(fro(s));
            })(dictChoice);
        };
    };
};

// | `nearly` is a variant of `only`. Like `only`, `nearly` produces
// | a prism that matches
// | a single value. Unlike `only`, it uses a predicate you supply
// | instead of depending on `class Eq`: 
// | 
// | ```purescript
// | solidWhiteFocus :: Prism' Fill Unit
// | solidWhiteFocus = nearly (Solid Color.white) predicate
// |   where
// |     predicate candidate =
// |       color.toHexString == Color.white.toHexString
// | ```
var nearly = function (x) {
    return function (f) {
        return function (dictChoice) {
            return prism$prime(Data_Function["const"](x))((function () {
                var $14 = Control_Alternative.guard(Data_Maybe.alternativeMaybe);
                return function ($15) {
                    return $14(f($15));
                };
            })())(dictChoice);
        };
    };
};

// | `only` focuses not just on a case, but a specific value of that case.
// | 
// | ```purescript
// | solidWhiteFocus :: Prism' Fill Unit
// | solidWhiteFocus = only $ Solid Color.white
// |
// | is      solidWhiteFocus (Solid Color.white) == true
// | preview solidWhiteFocus (Solid Color.white) == Just unit
// | review  solidWhiteFocus unit                == Solid Color.white
// | ```
// |
// | *Note*: `only` depends on `Eq`. Strange definitions of `(==)`
// | (for example, that it counts any `Fill` as being equal to `Solid Color.white`)
// | will create a prism that violates the preview-review law. 
var only = function (dictEq) {
    return function (x) {
        return function (dictChoice) {
            return nearly(x)(function (v) {
                return Data_Eq.eq(dictEq)(v)(x);
            })(dictChoice);
        };
    };
};
var matching = function (l) {
    return withPrism(l)(function (v) {
        return function (f) {
            return f;
        };
    });
};

//| Ask if `preview prism` would produce a `Just`.
var is = function (dictHeytingAlgebra) {
    return function (l) {
        var $16 = Data_Either.either(Data_Function["const"](Data_HeytingAlgebra.ff(dictHeytingAlgebra)))(Data_Function["const"](Data_HeytingAlgebra.tt(dictHeytingAlgebra)));
        var $17 = matching(l);
        return function ($18) {
            return $16($17($18));
        };
    };
};

//| Ask if `preview prism` would produce a `Nothing`.
var isn$primet = function (dictHeytingAlgebra) {
    return function (l) {
        var $19 = Data_HeytingAlgebra.not(dictHeytingAlgebra);
        var $20 = is(dictHeytingAlgebra)(l);
        return function ($21) {
            return $19($20($21));
        };
    };
};
var clonePrism = function (l) {
    return function (dictChoice) {
        return withPrism(l)(function (x) {
            return function (y) {
                return function (p) {
                    return prism(x)(y)(dictChoice)(p);
                };
            };
        });
    };
};
module.exports = {
    "prism'": prism$prime,
    prism: prism,
    only: only,
    nearly: nearly,
    review: review,
    is: is,
    "isn't": isn$primet,
    matching: matching,
    clonePrism: clonePrism,
    withPrism: withPrism
};
