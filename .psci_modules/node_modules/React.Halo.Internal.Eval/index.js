"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Applicative_Free = require("../Control.Applicative.Free/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Monad = require("../Control.Monad/index.js");
var Control_Monad_Error_Class = require("../Control.Monad.Error.Class/index.js");
var Control_Monad_Free = require("../Control.Monad.Free/index.js");
var Control_Parallel_Class = require("../Control.Parallel.Class/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Effect = require("../Effect/index.js");
var Effect_Aff = require("../Effect.Aff/index.js");
var Effect_Class = require("../Effect.Class/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var Effect_Ref = require("../Effect.Ref/index.js");
var Halogen_Subscription = require("../Halogen.Subscription/index.js");
var React_Halo_Internal_Control = require("../React.Halo.Internal.Control/index.js");
var React_Halo_Internal_State = require("../React.Halo.Internal.State/index.js");
var React_Halo_Internal_Types = require("../React.Halo.Internal.Types/index.js");
var Unsafe_Reference = require("../Unsafe.Reference/index.js");

// | Simple way to run Aff logic asynchronously, while bringing errors back into Effect.
var runAff = Effect_Aff.runAff_(Data_Either.either(Control_Monad_Error_Class.throwError(Control_Monad_Error_Class.monadThrowEffect))(Control_Applicative.pure(Effect.applicativeEffect)));
var handleAction = function (v) {
    return function (action) {
        return Control_Monad.unlessM(Effect.monadEffect)(Effect_Ref.read(v.finalized))(runAff(evalHaloM(v)(v["eval"](new React_Halo_Internal_Types.Action(action)))));
    };
};

// | Interprets `HaloM` into the base monad `Aff` for asynchronous effects.
var evalHaloM = function (hs) {
    return function (v) {
        return Control_Monad_Free.foldFree(Effect_Aff.monadRecAff)(evalHaloF(hs))(v);
    };
};

// | Interprets `HaloF` into the base monad `Aff`, keeping track of state in `HaloState`.
var evalHaloF = function (v) {
    return function (v1) {
        if (v1 instanceof React_Halo_Internal_Control.Props) {
            return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                var props = Effect_Ref.read(v.props)();
                return v1.value0(props);
            });
        };
        if (v1 instanceof React_Halo_Internal_Control.Context) {
            return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                var context = Effect_Ref.read(v.context)();
                return v1.value0(context);
            });
        };
        if (v1 instanceof React_Halo_Internal_Control.State) {
            return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                var state = Effect_Ref.read(v.state)();
                var v2 = v1.value0(state);
                if (Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraFunction(Data_HeytingAlgebra.heytingAlgebraFunction(Data_HeytingAlgebra.heytingAlgebraBoolean)))(Unsafe_Reference.unsafeRefEq)(state)(v2.value1)) {
                    Effect_Ref.write(v2.value1)(v.state)();
                    v.update(v2.value1)();
                    return v2.value0;
                };
                if (Data_Boolean.otherwise) {
                    return v2.value0;
                };
                throw new Error("Failed pattern match at React.Halo.Internal.Eval (line 45, column 7 - line 51, column 32): " + [ v2.constructor.name ]);
            });
        };
        if (v1 instanceof React_Halo_Internal_Control.Subscribe) {
            return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                var sid = React_Halo_Internal_State.fresh(React_Halo_Internal_Types.SubscriptionId)(v)();
                Control_Monad.unlessM(Effect.monadEffect)(Effect_Ref.read(v.finalized))(function __do() {
                    var canceller = Halogen_Subscription.subscribe(v1.value0(sid))(handleAction(v))();
                    return Effect_Ref.modify_(Data_Map_Internal.insert(React_Halo_Internal_Types.ordSubscriptionId)(sid)(canceller))(v.subscriptions)();
                })();
                return v1.value1(sid);
            });
        };
        if (v1 instanceof React_Halo_Internal_Control.Unsubscribe) {
            return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                var subscription = Data_Functor.map(Effect.functorEffect)(Data_Map_Internal.lookup(React_Halo_Internal_Types.ordSubscriptionId)(v1.value0))(Effect_Ref.read(v.subscriptions))();
                Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(Halogen_Subscription.unsubscribe)(subscription)();
                return v1.value1;
            });
        };
        if (v1 instanceof React_Halo_Internal_Control.Lift) {
            return v1.value0;
        };
        if (v1 instanceof React_Halo_Internal_Control.Par) {
            return Control_Parallel_Class.sequential(Effect_Aff.parallelAff)(evalHaloAp(v)(v1.value0));
        };
        if (v1 instanceof React_Halo_Internal_Control.Fork) {
            return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                var fid = React_Halo_Internal_State.fresh(React_Halo_Internal_Types.ForkId)(v)();
                var doneRef = Effect_Ref["new"](false)();
                var fiber = Effect_Aff.launchAff(Effect_Aff["finally"](Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
                    Effect_Ref.modify_(Data_Map_Internal["delete"](React_Halo_Internal_Types.ordForkId)(fid))(v.forks)();
                    return Effect_Ref.write(true)(doneRef)();
                }))(evalHaloM(v)(v1.value0)))();
                Control_Monad.unlessM(Effect.monadEffect)(Effect_Ref.read(doneRef))(Effect_Ref.modify_(Data_Map_Internal.insert(React_Halo_Internal_Types.ordForkId)(fid)(fiber))(v.forks))();
                return v1.value1(fid);
            });
        };
        if (v1 instanceof React_Halo_Internal_Control.Kill) {
            return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(v.forks)))(function (forks) {
                return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_Foldable.foldableMaybe)(Effect_Aff.killFiber(Effect_Exception.error("Cancelled")))(Data_Map_Internal.lookup(React_Halo_Internal_Types.ordForkId)(v1.value0)(forks)))(function () {
                    return Control_Applicative.pure(Effect_Aff.applicativeAff)(v1.value1);
                });
            });
        };
        throw new Error("Failed pattern match at React.Halo.Internal.Eval (line 33, column 30 - line 84, column 11): " + [ v1.constructor.name ]);
    };
};

// | Interprets `HaloAp` into the base applicative `ParAff` for parallel effects.
var evalHaloAp = function (hs) {
    return function (v) {
        return Control_Applicative_Free.foldFreeAp(Effect_Aff.applicativeParAff)((function () {
            var $48 = Control_Parallel_Class.parallel(Effect_Aff.parallelAff);
            var $49 = evalHaloM(hs);
            return function ($50) {
                return $48($49($50));
            };
        })())(v);
    };
};
var handleUpdate = function (v) {
    return function (props) {
        return function (context) {
            return function __do() {
                var props$prime = Effect_Ref.read(v.props)();
                var context$prime = Effect_Ref.read(v.context)();
                return Control_Applicative.unless(Effect.applicativeEffect)(Unsafe_Reference.unsafeRefEq(props)(props$prime) && Unsafe_Reference.unsafeRefEq(context)(context$prime))(function __do() {
                    Effect_Ref.write(props)(v.props)();
                    Effect_Ref.write(context)(v.context)();
                    return runAff(evalHaloM(v)(v["eval"](new React_Halo_Internal_Types.Update({
                        props: props$prime,
                        context: context$prime
                    }, {
                        props: props,
                        context: context
                    }))))();
                })();
            };
        };
    };
};
var runFinalize = function (v) {
    return function __do() {
        Effect_Ref.write(true)(v.finalized)();
        var subscriptions = Effect_Ref["modify'"](function (s$prime) {
            return {
                state: Data_Map_Internal.empty,
                value: s$prime
            };
        })(v.subscriptions)();
        Data_Foldable.traverse_(Effect.applicativeEffect)(Data_List_Types.foldableList)(Halogen_Subscription.unsubscribe)(Data_Map_Internal.values(subscriptions))();
        var forks = Effect_Ref["modify'"](function (s$prime) {
            return {
                state: Data_Map_Internal.empty,
                value: s$prime
            };
        })(v.forks)();
        Data_Foldable.traverse_(Effect.applicativeEffect)(Data_List_Types.foldableList)((function () {
            var $51 = Effect_Aff.killFiber(Effect_Exception.error("Cancelled"));
            return function ($52) {
                return runAff($51($52));
            };
        })())(Data_Map_Internal.values(forks))();
        return runAff(evalHaloM(v)(v["eval"](React_Halo_Internal_Types.Finalize.value)))();
    };
};
var runInitialize = function (v) {
    return function __do() {
        var props = Effect_Ref.read(v.props)();
        var context = Effect_Ref.read(v.context)();
        return runAff(evalHaloM(v)(v["eval"](new React_Halo_Internal_Types.Initialize({
            props: props,
            context: context
        }))))();
    };
};

// | The empty `EvalSpec`.
var defaultEval = {
    onInitialize: function (v) {
        return Data_Maybe.Nothing.value;
    },
    onUpdate: function (v) {
        return function (v1) {
            return Data_Maybe.Nothing.value;
        };
    },
    onAction: function (v) {
        return Control_Applicative.pure(React_Halo_Internal_Control.applicativeHaloM)(Data_Unit.unit);
    },
    onFinalize: Data_Maybe.Nothing.value
};

// | Given an `EvalSpec` builder, it will return an eval function.
var mkEval = function (f) {
    var $$eval = f(defaultEval);
    return function (v) {
        if (v instanceof React_Halo_Internal_Types.Initialize) {
            return Data_Foldable.traverse_(React_Halo_Internal_Control.applicativeHaloM)(Data_Foldable.foldableMaybe)($$eval.onAction)($$eval.onInitialize(v.value0));
        };
        if (v instanceof React_Halo_Internal_Types.Update) {
            return Data_Foldable.traverse_(React_Halo_Internal_Control.applicativeHaloM)(Data_Foldable.foldableMaybe)($$eval.onAction)($$eval.onUpdate(v.value0)(v.value1));
        };
        if (v instanceof React_Halo_Internal_Types.Action) {
            return $$eval.onAction(v.value0);
        };
        if (v instanceof React_Halo_Internal_Types.Finalize) {
            return Data_Foldable.traverse_(React_Halo_Internal_Control.applicativeHaloM)(Data_Foldable.foldableMaybe)($$eval.onAction)($$eval.onFinalize);
        };
        throw new Error("Failed pattern match at React.Halo.Internal.Eval (line 110, column 12 - line 114, column 54): " + [ v.constructor.name ]);
    };
};
module.exports = {
    evalHaloM: evalHaloM,
    evalHaloAp: evalHaloAp,
    evalHaloF: evalHaloF,
    defaultEval: defaultEval,
    mkEval: mkEval,
    runAff: runAff,
    runInitialize: runInitialize,
    handleUpdate: handleUpdate,
    handleAction: handleAction,
    runFinalize: runFinalize
};
