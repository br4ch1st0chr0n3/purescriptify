"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Show_Generic = require("../Data.Show.Generic/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");
var URI_Path_Segment = require("../URI.Path.Segment/index.js");

// | An absolute path, corresponding to _path-absolute_ in the spec. This path
// | cannot represent the value `//` - it must either be `/`, or start with a
// | segment that is not empty, for example: `/something`, `/.`, `/..`. This
// | type can appear in both hierarchical-part and relative-parts to represent
// | an absolute path when no authority component is present.
// |
// | This restriction exists as a value begining with `//` at this point in the
// | grammar must be an authority, attempting to decide whether a value is an
// | authority or a path would be ambiguous if `//` paths were allowed. The `//`
// | path means the same thing as `/` anyway!
var PathAbsolute = function (x) {
    return x;
};

// | A printer for a _path-absolute_ URI component.
var print = function (v) {
    if (v instanceof Data_Maybe.Nothing) {
        return "/";
    };
    if (v instanceof Data_Maybe.Just && v.value0.value1.length === 0) {
        return "/" + URI_Path_Segment.printSegmentNZ(v.value0.value0);
    };
    if (v instanceof Data_Maybe.Just) {
        return "/" + (URI_Path_Segment.printSegmentNZ(v.value0.value0) + ("/" + Data_String_Common.joinWith("/")(Data_Functor.map(Data_Functor.functorArray)(URI_Path_Segment.printSegment)(v.value0.value1))));
    };
    throw new Error("Failed pattern match at URI.Path.Absolute (line 45, column 9 - line 54, column 53): " + [ v.constructor.name ]);
};

// | A parser for a _path-absolute_ URI component.
var parse = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("/"))(function () {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.optionMaybe(Data_Identity.monadIdentity)(URI_Path_Segment.parseSegmentNZ))(function (v) {
        if (v instanceof Data_Maybe.Just) {
            return Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))((function () {
                var $27 = Data_Tuple.Tuple.create(v.value0);
                return function ($28) {
                    return PathAbsolute(Data_Maybe.Just.create($27($28)));
                };
            })())(Data_Array.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("/"))(URI_Path_Segment.parseSegment)));
        };
        if (v instanceof Data_Maybe.Nothing) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Data_Maybe.Nothing.value);
        };
        throw new Error("Failed pattern match at URI.Path.Absolute (line 37, column 34 - line 41, column 34): " + [ v.constructor.name ]);
    });
});
var genericPathAbsolute = {
    to: function (x) {
        return x;
    },
    from: function (x) {
        return x;
    }
};
var showPathAbsolute = {
    show: Data_Show_Generic.genericShow(genericPathAbsolute)(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsArgument(Data_Maybe.showMaybe(Data_Tuple.showTuple(URI_Path_Segment.showPathSegmentNZ)(Data_Show.showArray(URI_Path_Segment.showPathSegment)))))({
        reflectSymbol: function () {
            return "PathAbsolute";
        }
    }))
};
var eqPathAbsolute = {
    eq: function (x) {
        return function (y) {
            return Data_Eq.eq(Data_Maybe.eqMaybe(Data_Tuple.eqTuple(URI_Path_Segment.eqPathSegmentNZ)(Data_Eq.eqArray(URI_Path_Segment.eqPathSegment))))(x)(y);
        };
    }
};
var ordPathAbsolute = {
    compare: function (x) {
        return function (y) {
            return Data_Ord.compare(Data_Maybe.ordMaybe(Data_Tuple.ordTuple(URI_Path_Segment.ordPathSegmentNZ)(Data_Ord.ordArray(URI_Path_Segment.ordPathSegment))))(x)(y);
        };
    },
    Eq0: function () {
        return eqPathAbsolute;
    }
};
module.exports = {
    PathAbsolute: PathAbsolute,
    parse: parse,
    print: print,
    eqPathAbsolute: eqPathAbsolute,
    ordPathAbsolute: ordPathAbsolute,
    genericPathAbsolute: genericPathAbsolute,
    showPathAbsolute: showPathAbsolute
};
