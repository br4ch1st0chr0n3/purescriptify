"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Show_Generic = require("../Data.Show.Generic/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");
var URI_Path_Segment = require("../URI.Path.Segment/index.js");

// | A relative path that doesn't look like a URI scheme, corresponding to
// | _path-noscheme_ in the spec. This path cannot start with the character
// | `/`, contain the character `:` before the first `/`, or be entirely empty.
// | This type can appear in a relative-part when there is no authority
// | component.
var PathNoScheme = function (x) {
    return x;
};

// | A printer for a _path-noscheme_ URI component.
var print = function (v) {
    if (v.value1.length === 0) {
        return URI_Path_Segment.printSegmentNZNC(v.value0);
    };
    return URI_Path_Segment.printSegmentNZNC(v.value0) + ("/" + Data_String_Common.joinWith("/")(Data_Functor.map(Data_Functor.functorArray)(URI_Path_Segment.printSegment)(v.value1)));
};

// | A parser for a _path-noscheme_ URI component.
var parse = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(URI_Path_Segment.parseSegmentNZNC)(function (head) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("/"))(URI_Path_Segment.parseSegment)))(function (tail) {
        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Data_Tuple.Tuple(head, tail));
    });
});
var genericPathNoScheme = {
    to: function (x) {
        return x;
    },
    from: function (x) {
        return x;
    }
};
var showPathNoScheme = {
    show: Data_Show_Generic.genericShow(genericPathNoScheme)(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsArgument(Data_Tuple.showTuple(URI_Path_Segment.showPathSegmentNZNC)(Data_Show.showArray(URI_Path_Segment.showPathSegment))))({
        reflectSymbol: function () {
            return "PathNoScheme";
        }
    }))
};
var eqPathNoScheme = {
    eq: function (x) {
        return function (y) {
            return Data_Eq.eq(Data_Tuple.eqTuple(URI_Path_Segment.eqPathSegmentNZNC)(Data_Eq.eqArray(URI_Path_Segment.eqPathSegment)))(x)(y);
        };
    }
};
var ordPathNoScheme = {
    compare: function (x) {
        return function (y) {
            return Data_Ord.compare(Data_Tuple.ordTuple(URI_Path_Segment.ordPathSegmentNZNC)(Data_Ord.ordArray(URI_Path_Segment.ordPathSegment)))(x)(y);
        };
    },
    Eq0: function () {
        return eqPathNoScheme;
    }
};
module.exports = {
    PathNoScheme: PathNoScheme,
    parse: parse,
    print: print,
    eqPathNoScheme: eqPathNoScheme,
    ordPathNoScheme: ordPathNoScheme,
    genericPathNoScheme: genericPathNoScheme,
    showPathNoScheme: showPathNoScheme
};
