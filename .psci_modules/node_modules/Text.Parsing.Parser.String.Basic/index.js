
// | Basic `String` parsers derived from primitive `String` parsers.
// |
// | Note: In the future, the
// | __noneOf__, __noneOfCodePoints__, __oneOf__, __oneOfCodePoints__, __skipSpaces__, __whiteSpace__
// | should be moved into this module and removed from the
// | __Text.Parsing.Parser.String__ module, because they are not primitive parsers.
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_CodePoint_Unicode = require("../Data.CodePoint.Unicode/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Number = require("../Data.Number/index.js");
var Data_String_CodePoints = require("../Data.String.CodePoints/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");

// | Helper function
var satisfyCP = function (dictMonad) {
    return function (p) {
        return Text_Parsing_Parser_String.satisfy(dictMonad)(function ($24) {
            return p(Data_String_CodePoints.codePointFromChar($24));
        });
    };
};

// | Parse a space character.  Matches any char that satisfies `Data.CodePoint.Unicode.isSpace`.
var space = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isSpace))("space");
};

// | Parse an uppercase letter.  Matches any char that satisfies `Data.CodePoint.Unicode.isUpper`.
var upper = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isUpper))("uppercase letter");
};

// | Parse an octal digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isOctDigit`.
var octDigit = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isOctDigit))("oct digit");
};

// | Parser based on the __Data.Number.fromString__ function.
// |
// | This should be the inverse of `show :: String -> Number`.
// |
// | Examples of strings which can be parsed by this parser:
// | * `"3"`
// | * `"3.0"`
// | * `"0.3"`
// | * `"-0.3"`
// | * `"+0.3"`
// | * `"-3e-1"`
// | * `"-3.0E-1.0"`
// | * `"NaN"`
// | * `"-Infinity"`
var number = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(dictMonad)([ Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.string(dictMonad)("Infinity"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Number.infinity)), Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.string(dictMonad)("+Infinity"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Number.infinity)), Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.string(dictMonad)("-Infinity"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(-Data_Number.infinity)), Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.string(dictMonad)("NaN"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Number.nan)), Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.match(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(dictMonad)([ "+", "-", ".", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]))(function () {
        return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_String.oneOf(dictMonad)([ "e", "E", "+", "-", ".", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]));
    })))(function (v) {
        var v1 = Data_Number.fromString(v.value0);
        if (v1 instanceof Data_Maybe.Nothing) {
            return Text_Parsing_Parser.fail(dictMonad)("Could not parse Number " + v.value0);
        };
        if (v1 instanceof Data_Maybe.Just) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0);
        };
        throw new Error("Failed pattern match at Text.Parsing.Parser.String.Basic (line 95, column 9 - line 97, column 27): " + [ v1.constructor.name ]);
    }) ]);
};

// | Parse an alphabetical character.  Matches any char that satisfies `Data.CodePoint.Unicode.isAlpha`.
var letter = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isAlpha))("letter");
};

// | Parser based on the __Data.Int.fromString__ function.
// |
// | This should be the inverse of `show :: String -> Int`.
// |
// | Examples of strings which can be parsed by this parser:
// | * `"3"`
// | * `"-3"`
// | * `"+300"`
var intDecimal = function (dictMonad) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.match(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(dictMonad)([ "+", "-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]))(function () {
        return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_String.oneOf(dictMonad)([ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]));
    })))(function (v) {
        var v1 = Data_Int.fromString(v.value0);
        if (v1 instanceof Data_Maybe.Nothing) {
            return Text_Parsing_Parser.fail(dictMonad)("Could not parse Int " + v.value0);
        };
        if (v1 instanceof Data_Maybe.Just) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0);
        };
        throw new Error("Failed pattern match at Text.Parsing.Parser.String.Basic (line 113, column 3 - line 115, column 21): " + [ v1.constructor.name ]);
    });
};

// | Parse a hex digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isHexDigit`.
var hexDigit = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isHexDigit))("hex digit");
};

// | Parse a digit.  Matches any char that satisfies `Data.CodePoint.Unicode.isDecDigit`.
var digit = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isDecDigit))("digit");
};

// | Parse an alphabetical or numerical character.
// | Matches any char that satisfies `Data.CodePoint.Unicode.isAlphaNum`.
var alphaNum = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isAlphaNum))("letter or digit");
};
module.exports = {
    digit: digit,
    hexDigit: hexDigit,
    octDigit: octDigit,
    letter: letter,
    space: space,
    upper: upper,
    alphaNum: alphaNum,
    intDecimal: intDecimal,
    number: number,
    noneOf: Text_Parsing_Parser_String.noneOf,
    noneOfCodePoints: Text_Parsing_Parser_String.noneOfCodePoints,
    oneOf: Text_Parsing_Parser_String.oneOf,
    oneOfCodePoints: Text_Parsing_Parser_String.oneOfCodePoints,
    skipSpaces: Text_Parsing_Parser_String.skipSpaces,
    whiteSpace: Text_Parsing_Parser_String.whiteSpace
};
