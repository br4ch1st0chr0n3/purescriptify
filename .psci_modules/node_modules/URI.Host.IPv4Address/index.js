"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Partial_Unsafe = require("../Partial.Unsafe/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");
var Text_Parsing_Parser_String_Basic = require("../Text.Parsing.Parser.String.Basic/index.js");
var URI_Common = require("../URI.Common/index.js");

// | The IPv4 address variation of the host part of a URI.
var IPv4Address = (function () {
    function IPv4Address(value0, value1, value2, value3) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
        this.value3 = value3;
    };
    IPv4Address.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return function (value3) {
                    return new IPv4Address(value0, value1, value2, value3);
                };
            };
        };
    };
    return IPv4Address;
})();
var toInt = function (s) {
    var v = Data_Int.fromString(s);
    if (v instanceof Data_Maybe.Just && (v.value0 >= 0 && v.value0 <= 255)) {
        return new Data_Either.Right(v.value0);
    };
    return new Data_Either.Left("Invalid IPv4 address octet");
};
var showIPv4Address = {
    show: function (v) {
        return "(IPv4Address.unsafeFromInts " + (Data_Show.show(Data_Show.showInt)(v.value0) + (" " + (Data_Show.show(Data_Show.showInt)(v.value1) + (" " + (Data_Show.show(Data_Show.showInt)(v.value2) + (" " + (Data_Show.show(Data_Show.showInt)(v.value3) + ")")))))));
    }
};

// | A printer for IPv4 adddresses.
var print = function (v) {
    return Data_Show.show(Data_Show.showInt)(v.value0) + ("." + (Data_Show.show(Data_Show.showInt)(v.value1) + ("." + (Data_Show.show(Data_Show.showInt)(v.value2) + ("." + Data_Show.show(Data_Show.showInt)(v.value3))))));
};
var nzDigit = Text_Parsing_Parser_String.satisfy(Data_Identity.monadIdentity)(function (c) {
    return c >= "1" && c <= "9";
});
var octet = URI_Common.wrapParser(Data_Identity.monadIdentity)(toInt)(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(function (x) {
    return function (y) {
        return function (z) {
            return Data_String_CodeUnits.fromCharArray([ x, y, z ]);
        };
    };
})(nzDigit))(Text_Parsing_Parser_String_Basic.digit(Data_Identity.monadIdentity)))(Text_Parsing_Parser_String_Basic.digit(Data_Identity.monadIdentity))))(Text_Parsing_Parser_Combinators["try"](Data_Identity.monadIdentity)(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(function (x) {
    return function (y) {
        return Data_String_CodeUnits.fromCharArray([ x, y ]);
    };
})(nzDigit))(Text_Parsing_Parser_String_Basic.digit(Data_Identity.monadIdentity)))))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_String_CodeUnits.singleton)(Text_Parsing_Parser_String_Basic.digit(Data_Identity.monadIdentity))));

// | A parser for IPv4 addresses.
var parser = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(octet)(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)(".")))(function (o1) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(octet)(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)(".")))(function (o2) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(octet)(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)(".")))(function (o3) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(octet)(function (o4) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new IPv4Address(o1, o2, o3, o4));
            });
        });
    });
});

// | Constructs a `IPv4Address` part safely: bounds-checks each octet to ensure
// | it occurs within the range 0-255 (inclusive).
var fromInts = function (o1) {
    return function (o2) {
        return function (o3) {
            return function (o4) {
                var check = function (i) {
                    if (i >= 0 && i <= 255) {
                        return new Data_Maybe.Just(i);
                    };
                    if (Data_Boolean.otherwise) {
                        return Data_Maybe.Nothing.value;
                    };
                    throw new Error("Failed pattern match at URI.Host.IPv4Address (line 38, column 5 - line 38, column 28): " + [ i.constructor.name ]);
                };
                return Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(IPv4Address.create)(check(o1)))(check(o2)))(check(o3)))(check(o4));
            };
        };
    };
};

// | Constructs a `IPv4Address` part unsafely: if any of the arguments are
// | outside the allowable bounds, a runtime error will be thrown.
// |
// | This is intended as a convenience when describing `IPv4Address`es
// | statically in PureScript code, in all other cases `fromInts` should be
// | used.
var unsafeFromInts = function (o1) {
    return function (o2) {
        return function (o3) {
            return function (o4) {
                var v = fromInts(o1)(o2)(o3)(o4);
                if (v instanceof Data_Maybe.Just) {
                    return v.value0;
                };
                if (v instanceof Data_Maybe.Nothing) {
                    return Partial_Unsafe.unsafeCrashWith("IPv4Address octet was out of range");
                };
                throw new Error("Failed pattern match at URI.Host.IPv4Address (line 51, column 3 - line 53, column 67): " + [ v.constructor.name ]);
            };
        };
    };
};
var eqIPv4Address = {
    eq: function (x) {
        return function (y) {
            return x.value0 === y.value0 && x.value1 === y.value1 && x.value2 === y.value2 && x.value3 === y.value3;
        };
    }
};
var ordIPv4Address = {
    compare: function (x) {
        return function (y) {
            var v = Data_Ord.compare(Data_Ord.ordInt)(x.value0)(y.value0);
            if (v instanceof Data_Ordering.LT) {
                return Data_Ordering.LT.value;
            };
            if (v instanceof Data_Ordering.GT) {
                return Data_Ordering.GT.value;
            };
            var v1 = Data_Ord.compare(Data_Ord.ordInt)(x.value1)(y.value1);
            if (v1 instanceof Data_Ordering.LT) {
                return Data_Ordering.LT.value;
            };
            if (v1 instanceof Data_Ordering.GT) {
                return Data_Ordering.GT.value;
            };
            var v2 = Data_Ord.compare(Data_Ord.ordInt)(x.value2)(y.value2);
            if (v2 instanceof Data_Ordering.LT) {
                return Data_Ordering.LT.value;
            };
            if (v2 instanceof Data_Ordering.GT) {
                return Data_Ordering.GT.value;
            };
            return Data_Ord.compare(Data_Ord.ordInt)(x.value3)(y.value3);
        };
    },
    Eq0: function () {
        return eqIPv4Address;
    }
};
module.exports = {
    fromInts: fromInts,
    unsafeFromInts: unsafeFromInts,
    parser: parser,
    print: print,
    eqIPv4Address: eqIPv4Address,
    ordIPv4Address: ordIPv4Address,
    showIPv4Address: showIPv4Address
};
