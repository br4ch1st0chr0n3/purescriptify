"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Plus = require("../Control.Plus/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_TacitString = require("../Data.TacitString/index.js");

// | `Mu f` is the least fixed point of a functor `f`, when it exists.
var In = function (x) {
    return x;
};
var unroll = function (v) {
    return v;
};

// | `Show` is compositional, so we only `f` to be able to show a single layer of structure.
// Therefore, there is no need for `Show1`; we use `TacitString` in order to prevent
// extra quotes from appearing.
var showMu = function (dictShow) {
    return function (dictFunctor) {
        return {
            show: function (v) {
                return Data_Show.show(dictShow)(Data_Functor.mapFlipped(dictFunctor)(v)((function () {
                    var $24 = Data_Show.show(showMu(dictShow)(dictFunctor));
                    return function ($25) {
                        return Data_TacitString.hush($24($25));
                    };
                })()));
            }
        };
    };
};
var semigroupMu = function (dictAlt) {
    return {
        append: function (v) {
            return function (v1) {
                return Control_Alt.alt(dictAlt)(v)(v1);
            };
        }
    };
};
var roll = In;

// | Rewrites a tree along a natural transformation.
var transMu = function (dictFunctor) {
    return function (η) {
        var $26 = Data_Functor.map(dictFunctor)(transMu(dictFunctor)(η));
        return function ($27) {
            return roll($26(η(unroll($27))));
        };
    };
};
var newtypeMu = {
    Coercible0: function () {
        return undefined;
    }
};
var monoidMu = function (dictPlus) {
    return {
        mempty: Control_Plus.empty(dictPlus),
        Semigroup0: function () {
            return semigroupMu(dictPlus.Alt0());
        }
    };
};

// | To implement `Eq`, we require `f` to have higher-kinded equality.
var eqMu = function (dictEq1) {
    return {
        eq: function (v) {
            return function (v1) {
                return Data_Eq.eq1(dictEq1)(eqMu(dictEq1))(v)(v1);
            };
        }
    };
};

// | To implement `Ord`, we require `f` to have higher-kinded comparison.
var ordMu = function (dictEq1) {
    return function (dictOrd1) {
        return {
            compare: function (v) {
                return function (v1) {
                    return Data_Ord.compare1(dictOrd1)(ordMu(dictEq1)(dictOrd1))(v)(v1);
                };
            },
            Eq0: function () {
                return eqMu(dictEq1);
            }
        };
    };
};
module.exports = {
    In: In,
    roll: roll,
    unroll: unroll,
    transMu: transMu,
    newtypeMu: newtypeMu,
    eqMu: eqMu,
    ordMu: ordMu,
    showMu: showMu,
    semigroupMu: semigroupMu,
    monoidMu: monoidMu
};
