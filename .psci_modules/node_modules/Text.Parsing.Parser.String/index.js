
// | Primitive parsers for working with an input stream of type `String`.
// |
// | All of these primitive parsers will consume their input when they succeed.
// |
// | All of these primitive parsers will consume no input when they
// | fail.
// |
// | The behavior of these primitive parsers is based on the behavior of the
// | `Data.String` module in the __strings__ package.
// | In most JavaScript runtime environments, the `String`
// | is little-endian [UTF-16](https://en.wikipedia.org/wiki/UTF-16).
// |
// | The primitive parsers which return `Char` will only succeed when the character
// | being parsed is a code point in the
// | [Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane)
// | (the “BMP”). These parsers can be convenient because of the good support
// | that PureScript has for writing `Char` literals like `'あ'`, `'β'`, `'C'`.
// |
// | The other primitive parsers, which return `CodePoint` and `String` types,
// | can parse the full Unicode character set. All of the primitive parsers
// | in this module can be used together.
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Monad_State_Class = require("../Control.Monad.State.Class/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Char = require("../Data.Char/index.js");
var Data_CodePoint_Unicode = require("../Data.CodePoint.Unicode/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_CodePoints = require("../Data.String.CodePoints/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");

// | The CodePoint newtype constructor is not exported, so here's a helper.
// | This will break at runtime if the definition of CodePoint ever changes
// | to something other than `newtype CodePoint = CodePoint Int`.
var unCodePoint = Unsafe_Coerce.unsafeCoerce;

// | Updates a `Position` by adding the columns and lines in a
// | single `CodePoint`.
var updatePosSingle = function (v) {
    return function (cp) {
        var v1 = unCodePoint(cp);
        if (v1 === 10) {
            return {
                line: v.line + 1 | 0,
                column: 1
            };
        };
        if (v1 === 13) {
            return {
                line: v.line + 1 | 0,
                column: 1
            };
        };
        if (v1 === 9) {
            return {
                line: v.line,
                column: (v.column + 8 | 0) - Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v.column - 1 | 0)(8) | 0
            };
        };
        return {
            line: v.line,
            column: v.column + 1 | 0
        };
    };
};

// | Updates a `Position` by adding the columns and lines in `String`.
var updatePosString = function ($copy_pos) {
    return function ($copy_str) {
        var $tco_var_pos = $copy_pos;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(pos, str) {
            var v = Data_String_CodePoints.uncons(str);
            if (v instanceof Data_Maybe.Nothing) {
                $tco_done = true;
                return pos;
            };
            if (v instanceof Data_Maybe.Just) {
                $tco_var_pos = updatePosSingle(pos)(v.value0.head);
                $copy_str = v.value0.tail;
                return;
            };
            throw new Error("Failed pattern match at Text.Parsing.Parser.String (line 163, column 27 - line 165, column 73): " + [ v.constructor.name ]);
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_pos, $copy_str);
        };
        return $tco_result;
    };
};

// | Match a `String` exactly *N* characters long.
var takeN = function (dictMonad) {
    return function (n) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.get(Text_Parsing_Parser.monadStateParserT(dictMonad)))(function (v) {
            var v1 = Data_String_CodePoints.splitAt(n)(v.value0);
            var $47 = Data_String_CodePoints.length(v1.before) === n;
            if ($47) {
                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.put(Text_Parsing_Parser.monadStateParserT(dictMonad))(new Text_Parsing_Parser.ParseState(v1.after, updatePosString(v.value1)(v1.before), true)))(function () {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.before);
                });
            };
            return Text_Parsing_Parser.fail(dictMonad)("Could not take " + (Data_Show.show(Data_Show.showInt)(n) + " characters"));
        });
    };
};

// | Match the specified string.
var string = function (dictMonad) {
    return function (str) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.get(Text_Parsing_Parser.monadStateParserT(dictMonad)))(function (v) {
            var v1 = Data_String_CodeUnits.stripPrefix(str)(v.value0);
            if (v1 instanceof Data_Maybe.Just) {
                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.put(Text_Parsing_Parser.monadStateParserT(dictMonad))(new Text_Parsing_Parser.ParseState(v1.value0, updatePosString(v.value1)(str), true)))(function () {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(str);
                });
            };
            return Text_Parsing_Parser.fail(dictMonad)("Expected " + Data_Show.show(Data_Show.showString)(str));
        });
    };
};

// | Match the entire rest of the input stream. Always succeeds.
var rest = function (dictMonad) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.get(Text_Parsing_Parser.monadStateParserT(dictMonad)))(function (v) {
        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.put(Text_Parsing_Parser.monadStateParserT(dictMonad))(new Text_Parsing_Parser.ParseState("", updatePosString(v.value1)(v.value0), true)))(function () {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v.value0);
        });
    });
};

// | Combinator which returns both the result of a parse and the slice of
// | the input that was consumed while it was being parsed.
// |
// | Because `String`s are not `Char` arrays in PureScript, `many` and `some`
// | on `Char` parsers need to
// | be used with `Data.String.CodeUnits.fromCharArray` to
// | construct a `String`.
// |
// | ```
// | fromCharArray <$> Data.Array.many (char 'x')
// | ```
// |
// | It’s more efficient to achieve the same result by using this `match` combinator
// | instead of `fromCharArray`.
// |
// | ```
// | fst <$> match (Combinators.skipMany (char 'x'))
// | ```
var match = function (dictMonad) {
    return function (p) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.get(Text_Parsing_Parser.monadStateParserT(dictMonad)))(function (v) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (x) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.get(Text_Parsing_Parser.monadStateParserT(dictMonad)))(function (v1) {
                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_Tuple.Tuple(Data_String_CodeUnits.take(Data_String_CodeUnits.length(v.value0) - Data_String_CodeUnits.length(v1.value0) | 0)(v.value0), x));
                });
            });
        });
    };
};

// | Match “end-of-file,” the end of the input stream.
var eof = function (dictMonad) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.get(Text_Parsing_Parser.monadStateParserT(dictMonad)))(function (v) {
        var $72 = Data_String_Common["null"](v.value0);
        if ($72) {
            return Text_Parsing_Parser.consume(dictMonad);
        };
        return Text_Parsing_Parser.fail(dictMonad)("Expected EOF");
    });
};

// | Match any Unicode character.
// | Always succeeds.
var anyCodePoint = function (dictMonad) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.get(Text_Parsing_Parser.monadStateParserT(dictMonad)))(function (v) {
        var v1 = Data_String_CodePoints.uncons(v.value0);
        if (v1 instanceof Data_Maybe.Nothing) {
            return Text_Parsing_Parser.fail(dictMonad)("Unexpected EOF");
        };
        if (v1 instanceof Data_Maybe.Just) {
            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.put(Text_Parsing_Parser.monadStateParserT(dictMonad))(new Text_Parsing_Parser.ParseState(v1.value0.tail, updatePosSingle(v.value1)(v1.value0.head), true)))(function () {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0.head);
            });
        };
        throw new Error("Failed pattern match at Text.Parsing.Parser.String (line 102, column 3 - line 106, column 16): " + [ v1.constructor.name ]);
    });
};

// | Match a Unicode character satisfying the predicate.
var satisfyCodePoint = function (dictMonad) {
    return function (f) {
        return Text_Parsing_Parser_Combinators.tryRethrow(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(anyCodePoint(dictMonad))(function (c) {
            var $84 = f(c);
            if ($84) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(c);
            };
            return Text_Parsing_Parser.fail(dictMonad)("Predicate unsatisfied");
        }));
    };
};

// | Match any Unicode character not in the array.
var noneOfCodePoints = function (dictMonad) {
    return function (ss) {
        return Text_Parsing_Parser_Combinators.withLazyErrorMessage(dictMonad)(satisfyCodePoint(dictMonad)(Data_Function.flip(Data_Array.notElem(Data_String_CodePoints.eqCodePoint))(ss)))(function (v) {
            return "none of " + Data_Show.show(Data_Show.showArray(Data_Show.showString))(Data_Functor.map(Data_Functor.functorArray)(Data_String_CodePoints.singleton)(ss));
        });
    };
};

// | Match one of the Unicode characters in the array.
var oneOfCodePoints = function (dictMonad) {
    return function (ss) {
        return Text_Parsing_Parser_Combinators.withLazyErrorMessage(dictMonad)(satisfyCodePoint(dictMonad)(Data_Function.flip(Data_Foldable.elem(Data_Foldable.foldableArray)(Data_String_CodePoints.eqCodePoint))(ss)))(function (v) {
            return "one of " + Data_Show.show(Data_Show.showArray(Data_Show.showString))(Data_Functor.map(Data_Functor.functorArray)(Data_String_CodePoints.singleton)(ss));
        });
    };
};

// | Skip whitespace characters and throw them away. Always succeeds.
var skipSpaces = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(satisfyCodePoint(dictMonad)(Data_CodePoint_Unicode.isSpace));
};

// | Match zero or more whitespace characters satisfying
// | `Data.CodePoint.Unicode.isSpace`. Always succeeds.
var whiteSpace = function (dictMonad) {
    return Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Tuple.fst)(match(dictMonad)(skipSpaces(dictMonad)));
};

// | Match any BMP `Char`.
// | Parser will fail if the character is not in the Basic Multilingual Plane.
var anyChar = function (dictMonad) {
    return Text_Parsing_Parser_Combinators.tryRethrow(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(unCodePoint)(anyCodePoint(dictMonad)))(function (v) {
        var $86 = v > 65535;
        if ($86) {
            return Text_Parsing_Parser.fail(dictMonad)("Not a Char");
        };
        var v1 = Data_Char.fromCharCode(v);
        if (v1 instanceof Data_Maybe.Nothing) {
            return Text_Parsing_Parser.fail(dictMonad)("Not a Char");
        };
        if (v1 instanceof Data_Maybe.Just) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0);
        };
        throw new Error("Failed pattern match at Text.Parsing.Parser.String (line 93, column 8 - line 95, column 21): " + [ v1.constructor.name ]);
    }));
};

// | Match a BMP `Char` satisfying the predicate.
var satisfy = function (dictMonad) {
    return function (f) {
        return Text_Parsing_Parser_Combinators.tryRethrow(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(anyChar(dictMonad))(function (c) {
            var $89 = f(c);
            if ($89) {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(c);
            };
            return Text_Parsing_Parser.fail(dictMonad)("Predicate unsatisfied");
        }));
    };
};

// | Match the specified BMP `Char`.
var $$char = function (dictMonad) {
    return function (c) {
        return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfy(dictMonad)(function (v) {
            return v === c;
        }))(Data_Show.show(Data_Show.showChar)(c));
    };
};

// | Match any BMP `Char` not in the array.
var noneOf = function (dictMonad) {
    return function (ss) {
        return Text_Parsing_Parser_Combinators.withLazyErrorMessage(dictMonad)(satisfy(dictMonad)(Data_Function.flip(Data_Array.notElem(Data_Eq.eqChar))(ss)))(function (v) {
            return "none of " + Data_Show.show(Data_Show.showArray(Data_Show.showChar))(ss);
        });
    };
};

// | Match one of the BMP `Char`s in the array.
var oneOf = function (dictMonad) {
    return function (ss) {
        return Text_Parsing_Parser_Combinators.withLazyErrorMessage(dictMonad)(satisfy(dictMonad)(Data_Function.flip(Data_Foldable.elem(Data_Foldable.foldableArray)(Data_Eq.eqChar))(ss)))(function (v) {
            return "one of " + Data_Show.show(Data_Show.showArray(Data_Show.showChar))(ss);
        });
    };
};
module.exports = {
    string: string,
    eof: eof,
    rest: rest,
    anyChar: anyChar,
    anyCodePoint: anyCodePoint,
    satisfy: satisfy,
    satisfyCodePoint: satisfyCodePoint,
    "char": $$char,
    takeN: takeN,
    whiteSpace: whiteSpace,
    skipSpaces: skipSpaces,
    oneOf: oneOf,
    oneOfCodePoints: oneOfCodePoints,
    noneOf: noneOf,
    noneOfCodePoints: noneOfCodePoints,
    match: match
};
