
// | This module provides functions printing with cascading ANSI styles.
// | ANSI annotations closer to the root will cascade down to child nodes,
// | where styles closer to the leaves take precedence. Indentation is
// | never printed with ANSI styles, only the text elements of the document.
"use strict";
var Ansi_Codes = require("../Ansi.Codes/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_NonEmpty = require("../Data.List.NonEmpty/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Dodo = require("../Dodo/index.js");
var AnsiBuffer = function (x) {
    return x;
};

// | Prints a document with underline styling.
var underline = Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Underline.value));

// | Prints a document with strikethrough styling.
var strikethrough = Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Strikethrough.value));

// | Resets all cascading styles for a document so that outer styles won't
// | interfere with inner styles.
var reset = Dodo.annotate(Ansi_Codes.Reset.value);

// | Prints a document with italic styling.
var italic = Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Italic.value));

// | Prints a document with inverse styling.
var inverse = Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Inverse.value));

// | Prints a document with a specific foreground color.
var foreground = function (color) {
    return Dodo.annotate(new Ansi_Codes.PForeground(color));
};

// | Prints a document with dim styling.
var dim = Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Dim.value));

// | Prints a document with bold styling.
var bold = Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Bold.value));

// | Prints a document with a specific background color.
var background = function (color) {
    return Dodo.annotate(new Ansi_Codes.PBackground(color));
};
var ansiGraphics = (function () {
    var writePendingGraphics = function (v) {
        if (v.pending instanceof Data_Maybe.Nothing) {
            return v;
        };
        if (v.pending instanceof Data_Maybe.Just) {
            return {
                output: v.output + Ansi_Codes.escapeCodeToString(new Ansi_Codes.Graphics(v.pending.value0)),
                pending: Data_Maybe.Nothing.value,
                current: v.current,
                previous: v.previous
            };
        };
        throw new Error("Failed pattern match at Dodo.Ansi (line 136, column 5 - line 143, column 12): " + [ v.pending.constructor.name ]);
    };
    var writeText = function (v) {
        return function (text) {
            return function (output) {
                var v1 = writePendingGraphics(output);
                return {
                    output: v1.output + text,
                    pending: v1.pending,
                    current: v1.current,
                    previous: Data_List_Types.Nil.value
                };
            };
        };
    };
    var writeIndent = function (v) {
        return function (text) {
            return function (v1) {
                return {
                    output: v1.output + text,
                    pending: v1.pending,
                    current: v1.current,
                    previous: v1.previous
                };
            };
        };
    };
    var resetCode = Ansi_Codes.escapeCodeToString(new Ansi_Codes.Graphics(Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList)(Ansi_Codes.Reset.value)));
    var graphicsConflict = function (v) {
        return function (v1) {
            if (v instanceof Ansi_Codes.Reset && v1 instanceof Ansi_Codes.Reset) {
                return true;
            };
            if (v instanceof Ansi_Codes.PForeground && v1 instanceof Ansi_Codes.PForeground) {
                return true;
            };
            if (v instanceof Ansi_Codes.PBackground && v1 instanceof Ansi_Codes.PBackground) {
                return true;
            };
            if (v instanceof Ansi_Codes.PMode && v1 instanceof Ansi_Codes.PMode) {
                return Data_Eq.eq(Ansi_Codes.eqRenderingMode)(v.value0)(v1.value0);
            };
            return false;
        };
    };
    var getPendingGraphics = (function () {
        var $43 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_List_NonEmpty.cons(Ansi_Codes.Reset.value));
        return function ($44) {
            return $43(Data_List_NonEmpty.fromList($44));
        };
    })();
    var writeBreak = function (v) {
        var pending = getPendingGraphics(v.current);
        var resetOrEmpty = (function () {
            var $35 = Data_Maybe.isNothing(pending) && Data_List["null"](v.previous);
            if ($35) {
                return "";
            };
            return resetCode;
        })();
        return {
            output: v.output + (resetOrEmpty + "\x0a"),
            pending: pending,
            current: v.current,
            previous: v.previous
        };
    };
    var getCurrentGraphics = (function () {
        var $45 = Data_List.nubByEq(graphicsConflict);
        var $46 = Data_List.takeWhile(function (v) {
            return Data_Eq.notEq(Ansi_Codes.eqGraphicsParam)(v)(Ansi_Codes.Reset.value);
        });
        return function ($47) {
            return Data_List.reverse($45($46($47)));
        };
    })();
    var leaveAnnotation = function (v) {
        return function (as) {
            return function (v1) {
                var current = getCurrentGraphics(as);
                return {
                    output: v1.output,
                    pending: new Data_Maybe.Just(Data_Maybe.fromMaybe(Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList)(Ansi_Codes.Reset.value))(getPendingGraphics(current))),
                    current: current,
                    previous: v1.current
                };
            };
        };
    };
    var flushBuffer = function (ansiBuffer) {
        var v = writePendingGraphics(ansiBuffer);
        return v.output;
    };
    var enterAnnotation = function (a) {
        return function (as) {
            return function (v) {
                var current = getCurrentGraphics(new Data_List_Types.Cons(a, as));
                return {
                    output: v.output,
                    pending: getPendingGraphics(current),
                    current: current,
                    previous: v.current
                };
            };
        };
    };
    var emptyBuffer = {
        output: "",
        pending: Data_Maybe.Nothing.value,
        current: Data_List_Types.Nil.value,
        previous: Data_List_Types.Nil.value
    };
    return {
        emptyBuffer: emptyBuffer,
        writeText: writeText,
        writeIndent: writeIndent,
        writeBreak: writeBreak,
        enterAnnotation: enterAnnotation,
        leaveAnnotation: leaveAnnotation,
        flushBuffer: flushBuffer
    };
})();
module.exports = {
    AnsiBuffer: AnsiBuffer,
    ansiGraphics: ansiGraphics,
    background: background,
    bold: bold,
    dim: dim,
    foreground: foreground,
    inverse: inverse,
    italic: italic,
    reset: reset,
    strikethrough: strikethrough,
    underline: underline,
    Black: Ansi_Codes.Black,
    Blue: Ansi_Codes.Blue,
    BrightBlack: Ansi_Codes.BrightBlack,
    BrightBlue: Ansi_Codes.BrightBlue,
    BrightCyan: Ansi_Codes.BrightCyan,
    BrightGreen: Ansi_Codes.BrightGreen,
    BrightMagenta: Ansi_Codes.BrightMagenta,
    BrightRed: Ansi_Codes.BrightRed,
    BrightWhite: Ansi_Codes.BrightWhite,
    BrightYellow: Ansi_Codes.BrightYellow,
    Cyan: Ansi_Codes.Cyan,
    Green: Ansi_Codes.Green,
    Magenta: Ansi_Codes.Magenta,
    Red: Ansi_Codes.Red,
    White: Ansi_Codes.White,
    Yellow: Ansi_Codes.Yellow
};
