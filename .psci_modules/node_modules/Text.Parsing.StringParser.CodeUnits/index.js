
// | Primitive parsers for strings, parsing based on code units.
// |
// | These functions will be much faster than the `CodePoints` alternatives, but
// | will behave incorrectly when dealing with Unicode characters that consist
// | of multiple code units.
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Array_NonEmpty = require("../Data.Array.NonEmpty/index.js");
var Data_Char = require("../Data.Char/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Data_String_Regex = require("../Data.String.Regex/index.js");
var Data_String_Regex_Flags = require("../Data.String.Regex.Flags/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Text_Parsing_StringParser = require("../Text.Parsing.StringParser/index.js");
var Text_Parsing_StringParser_Combinators = require("../Text.Parsing.StringParser.Combinators/index.js");

// | Match the specified string.
var string = function (nt) {
    return function (s) {
        if (Data_Eq.eq(Data_Maybe.eqMaybe(Data_Eq.eqInt))(Data_String_CodeUnits["indexOf'"](nt)(s.pos)(s.str))(new Data_Maybe.Just(s.pos))) {
            return new Data_Either.Right({
                result: nt,
                suffix: {
                    str: s.str,
                    pos: s.pos + Data_String_CodeUnits.length(nt) | 0
                }
            });
        };
        return new Data_Either.Left({
            pos: s.pos,
            error: "Expected '" + (nt + "'.")
        });
    };
};

// | match the regular expression
var regex = function (pat) {
    
    // ensure the pattern only matches the current position in the parse
var pattern = (function () {
        var v = Data_String_CodeUnits.stripPrefix("^")(pat);
        if (v instanceof Data_Maybe.Nothing) {
            return "^" + pat;
        };
        return pat;
    })();
    var matchRegex = function (r) {
        return function (v) {
            var remainder = Data_String_CodeUnits.drop(v.pos)(v.str);
            var v1 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Array_NonEmpty.head)(Data_String_Regex.match(r)(remainder));
            if (v1 instanceof Data_Maybe.Just && v1.value0 instanceof Data_Maybe.Just) {
                return new Data_Either.Right({
                    result: v1.value0.value0,
                    suffix: {
                        str: v.str,
                        pos: v.pos + Data_String_CodeUnits.length(v1.value0.value0) | 0
                    }
                });
            };
            return new Data_Either.Left({
                pos: v.pos,
                error: "no match"
            });
        };
    };
    var v = Data_String_Regex.regex(pattern)(Data_String_Regex_Flags.noFlags);
    if (v instanceof Data_Either.Left) {
        return Text_Parsing_StringParser.fail("Text.Parsing.StringParser.String.regex': illegal regex " + pat);
    };
    if (v instanceof Data_Either.Right) {
        return matchRegex(v.value0);
    };
    throw new Error("Failed pattern match at Text.Parsing.StringParser.CodeUnits (line 127, column 3 - line 131, column 19): " + [ v.constructor.name ]);
};

// | Match the end of the file.
var eof = function (s) {
    if (s.pos < Data_String_CodeUnits.length(s.str)) {
        return new Data_Either.Left({
            pos: s.pos,
            error: "Expected EOF"
        });
    };
    return new Data_Either.Right({
        result: Data_Unit.unit,
        suffix: s
    });
};

// | Match any character.
var anyChar = function (v) {
    var v1 = Data_String_CodeUnits.charAt(v.pos)(v.str);
    if (v1 instanceof Data_Maybe.Just) {
        return new Data_Either.Right({
            result: v1.value0,
            suffix: {
                str: v.str,
                pos: v.pos + 1 | 0
            }
        });
    };
    if (v1 instanceof Data_Maybe.Nothing) {
        return new Data_Either.Left({
            pos: v.pos,
            error: "Unexpected EOF"
        });
    };
    throw new Error("Failed pattern match at Text.Parsing.StringParser.CodeUnits (line 51, column 3 - line 53, column 53): " + [ v1.constructor.name ]);
};

// | Match any digit.
var anyDigit = Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (c) {
    var $31 = c >= "0" && c <= "9";
    if ($31) {
        return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(c);
    };
    return Text_Parsing_StringParser.fail("Character " + (Data_Show.show(Data_Show.showChar)(c) + " is not a digit"));
}));

// | Match any lower case character.
var lowerCaseChar = Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (c) {
    var $32 = Data_Foldable.elem(Data_Foldable.foldableArray)(Data_Eq.eqInt)(Data_Char.toCharCode(c))(Data_Array.range(97)(122));
    if ($32) {
        return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(c);
    };
    return Text_Parsing_StringParser.fail("Expected a lower case character but found " + Data_Show.show(Data_Show.showChar)(c));
}));

// | Match a character satisfying the given predicate.
var satisfy = function (f) {
    return Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (c) {
        var $33 = f(c);
        if ($33) {
            return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(c);
        };
        return Text_Parsing_StringParser.fail("Character " + (Data_Show.show(Data_Show.showChar)(c) + " did not satisfy predicate"));
    }));
};

// | Match the specified character.
var $$char = function (c) {
    return Text_Parsing_StringParser_Combinators.withError(satisfy(function (v) {
        return v === c;
    }))("Could not match character " + Data_Show.show(Data_Show.showChar)(c));
};

// | Match any character not in the foldable structure.
var noneOf = function (dictFoldable) {
    var $35 = Data_Function.flip(Data_Foldable.notElem(dictFoldable)(Data_Eq.eqChar));
    return function ($36) {
        return satisfy($35($36));
    };
};

// | Match one of the characters in the foldable structure.
var oneOf = function (dictFoldable) {
    var $37 = Data_Function.flip(Data_Foldable.elem(dictFoldable)(Data_Eq.eqChar));
    return function ($38) {
        return satisfy($37($38));
    };
};

// | Match many whitespace characters.
var whiteSpace = Control_Bind.bind(Text_Parsing_StringParser.bindParser)(Text_Parsing_StringParser_Combinators.many(satisfy(function (c) {
    return c === "\x0a" || (c === "\x0d" || (c === " " || c === "\x09"));
})))(function (cs) {
    return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(Data_Foldable.foldMap(Data_List_Types.foldableList)(Data_Monoid.monoidString)(Data_String_CodeUnits.singleton)(cs));
});

// | Skip many whitespace characters.
var skipSpaces = Data_Functor["void"](Text_Parsing_StringParser.functorParser)(whiteSpace);

// | Match any upper case character.
var upperCaseChar = Text_Parsing_StringParser["try"](Control_Bind.bind(Text_Parsing_StringParser.bindParser)(anyChar)(function (c) {
    var $34 = Data_Foldable.elem(Data_Foldable.foldableArray)(Data_Eq.eqInt)(Data_Char.toCharCode(c))(Data_Array.range(65)(90));
    if ($34) {
        return Control_Applicative.pure(Text_Parsing_StringParser.applicativeParser)(c);
    };
    return Text_Parsing_StringParser.fail("Expected an upper case character but found " + Data_Show.show(Data_Show.showChar)(c));
}));

// | Match any letter.
var anyLetter = Text_Parsing_StringParser_Combinators.withError(Control_Alt.alt(Text_Parsing_StringParser.altParser)(lowerCaseChar)(upperCaseChar))("Expected a letter");

// | Match a letter or a number.
var alphaNum = Text_Parsing_StringParser_Combinators.withError(Control_Alt.alt(Text_Parsing_StringParser.altParser)(anyLetter)(anyDigit))("Expected a letter or a number");
module.exports = {
    eof: eof,
    anyChar: anyChar,
    anyDigit: anyDigit,
    string: string,
    satisfy: satisfy,
    "char": $$char,
    whiteSpace: whiteSpace,
    skipSpaces: skipSpaces,
    oneOf: oneOf,
    noneOf: noneOf,
    lowerCaseChar: lowerCaseChar,
    upperCaseChar: upperCaseChar,
    anyLetter: anyLetter,
    alphaNum: alphaNum,
    regex: regex
};
