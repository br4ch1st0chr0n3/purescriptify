"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind_Indexed = require("../Control.Bind.Indexed/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Effect = require("../Effect/index.js");
var Render = function (x) {
    return x;
};

// | Promote an arbitrary Effect to a Pure render effect.
// |
// | This is unsafe because it allows arbitrary
// | effects to be performed during a render, which
// | may cause them to be run many times by React.
// | You should almost always prefer `useEffect`!
var unsafeRenderEffect = Render;

// | Promote an arbitrary Effect to a Hook.
// |
// | This is unsafe because it allows arbitrary
// | effects to be performed during a render, which
// | may cause them to be run many times by React.
// | This function is primarily for constructing
// | new hooks using the FFI. If you just want to
// | alias a safe hook's effects, prefer `coerceHook`.
// |
// | It's also unsafe because the author of the hook
// | type (the `newHook` type variable used here) _MUST_
// | contain all relevant types. For example, `UseState`
// | has a phantom type to track the type of the value contained.
// | `useEffect` tracks the type used as the deps. `useAff` tracks
// | both the deps and the resulting response's type. Forgetting
// | to do this allows the consumer to reorder hook effects. If
// | `useState` didn't track the return type the following
// | extremely unsafe code would be allowed:
// |
// | ```purs
// | React.do
// |   if xyz then
// |     _ <- useState 0
// |     useState Nothing
// |   else
// |     s <- useState Nothing
// |     _ <- useState 0
// |     pure s
// |   ...
// | ```
// |
// | The same applies to `deps` in these examples as they use
// | `Eq` and a reorder would allow React to pass incorrect
// | types into the `eq` function!
var unsafeHook = Render;
var semigroupRender = function (dictTypeEquals) {
    return function (dictSemigroup) {
        return {
            append: function (v) {
                return function (v1) {
                    return Data_Semigroup.append(Effect.semigroupEffect(dictSemigroup))(v)(v1);
                };
            }
        };
    };
};
var monoidRender = function (dictTypeEquals) {
    return function (dictMonoid) {
        return {
            mempty: Data_Monoid.mempty(Effect.monoidEffect(dictMonoid)),
            Semigroup0: function () {
                return semigroupRender(dictTypeEquals)(dictMonoid.Semigroup0());
            }
        };
    };
};
var ixFunctorRender = {
    imap: function (f) {
        return function (v) {
            return Data_Functor.map(Effect.functorEffect)(f)(v);
        };
    }
};
var ixApplyRender = {
    iapply: function (v) {
        return function (v1) {
            return Control_Apply.apply(Effect.applyEffect)(v)(v1);
        };
    },
    IxFunctor0: function () {
        return ixFunctorRender;
    }
};
var ixBindRender = {
    ibind: function (v) {
        return function (f) {
            return function __do() {
                var a = v();
                var v1 = f(a);
                return v1();
            };
        };
    },
    IxApply0: function () {
        return ixApplyRender;
    }
};
var ixApplicativeRender = {
    ipure: function (a) {
        return Control_Applicative.pure(Effect.applicativeEffect)(a);
    },
    IxApply0: function () {
        return ixApplyRender;
    }
};
var ixMonadRender = {
    IxApplicative0: function () {
        return ixApplicativeRender;
    },
    IxBind1: function () {
        return ixBindRender;
    }
};
var functorRender = {
    map: function (f) {
        return function (v) {
            return Data_Functor.map(Effect.functorEffect)(f)(v);
        };
    }
};

// | Exported for use with qualified-do syntax
var discard = function (dictIxBind) {
    return Control_Bind_Indexed.ibind(dictIxBind);
};

// | Rename/alias a chain of hooks. Useful for exposing a single
// | "clean" type when creating a hook to improve error messages
// | and hide implementation details, particularly for libraries
// | hiding internal info.
// |
// | For example, the following alias is technically correct but
// | when inspecting types or error messages the alias is expanded
// | to the full original type and `UseAff` is never seen:
// |
// | ```purs
// | type UseAff deps a hooks
// |   = UseEffect deps (UseState (Result a) hooks)
// |
// | useAff :: ... -> Hook (UseAff deps a) (Result a)
// | useAff deps aff = React.do
// |   ...
// | ```
// |
// | `coerceHook` allows the same code to safely export a newtype
// | instead, hiding the internal implementation:
// |
// | ```purs
// | newtype UseAff deps a hooks
// |   = UseAff (UseEffect deps (UseState (Result a) hooks))
// |
// | derive instance ntUseAff :: Newtype (UseAff deps a hooks) _
// |
// | useAff :: ... -> Hook (UseAff deps a) (Result a)
// | useAff deps aff = coerceHook React.do
// |   ...
// | ```
// |
// |
// |
var coerceHook = function () {
    return function (v) {
        return v;
    };
};

// | Exported for use with qualified-do syntax
var bind = function (dictIxBind) {
    return Control_Bind_Indexed.ibind(dictIxBind);
};
var applyRender = function (dictTypeEquals) {
    return {
        apply: function (v) {
            return function (v1) {
                return Control_Apply.apply(Effect.applyEffect)(v)(v1);
            };
        },
        Functor0: function () {
            return functorRender;
        }
    };
};
var bindRender = function (dictTypeEquals) {
    return {
        bind: function (v) {
            return function (f) {
                return function __do() {
                    var a = v();
                    var v1 = f(a);
                    return v1();
                };
            };
        },
        Apply0: function () {
            return applyRender(dictTypeEquals);
        }
    };
};
var applicativeRender = function (dictTypeEquals) {
    return {
        pure: function (a) {
            return Control_Applicative.pure(Effect.applicativeEffect)(a);
        },
        Apply0: function () {
            return applyRender(dictTypeEquals);
        }
    };
};
var monadRender = function (dictTypeEquals) {
    return {
        Applicative0: function () {
            return applicativeRender(dictTypeEquals);
        },
        Bind1: function () {
            return bindRender(dictTypeEquals);
        }
    };
};
module.exports = {
    coerceHook: coerceHook,
    unsafeHook: unsafeHook,
    unsafeRenderEffect: unsafeRenderEffect,
    bind: bind,
    discard: discard,
    ixFunctorRender: ixFunctorRender,
    ixApplyRender: ixApplyRender,
    ixApplicativeRender: ixApplicativeRender,
    ixBindRender: ixBindRender,
    ixMonadRender: ixMonadRender,
    functorRender: functorRender,
    applyRender: applyRender,
    applicativeRender: applicativeRender,
    bindRender: bindRender,
    monadRender: monadRender,
    semigroupRender: semigroupRender,
    monoidRender: monoidRender
};
