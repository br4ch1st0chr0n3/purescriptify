"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Applicative_Free = require("../Control.Applicative.Free/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Monad_Error_Class = require("../Control.Monad.Error.Class/index.js");
var Control_Monad_Free = require("../Control.Monad.Free/index.js");
var Control_Monad_Reader_Class = require("../Control.Monad.Reader.Class/index.js");
var Control_Monad_Rec_Class = require("../Control.Monad.Rec.Class/index.js");
var Control_Monad_Trans_Class = require("../Control.Monad.Trans.Class/index.js");
var Control_Monad_Writer_Class = require("../Control.Monad.Writer.Class/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Effect_Aff_Class = require("../Effect.Aff.Class/index.js");
var Effect_Class = require("../Effect.Class/index.js");

// | The Halo parallel evaluation applicative. It lifts `HaloM` into a free applicative.
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var HaloAp = function (x) {
    return x;
};

// | The Halo evaluation monad. It lifts the `HaloF` algebra into a free monad.
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var HaloM = function (x) {
    return x;
};

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Props = (function () {
    function Props(value0) {
        this.value0 = value0;
    };
    Props.create = function (value0) {
        return new Props(value0);
    };
    return Props;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Context = (function () {
    function Context(value0) {
        this.value0 = value0;
    };
    Context.create = function (value0) {
        return new Context(value0);
    };
    return Context;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var State = (function () {
    function State(value0) {
        this.value0 = value0;
    };
    State.create = function (value0) {
        return new State(value0);
    };
    return State;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Subscribe = (function () {
    function Subscribe(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Subscribe.create = function (value0) {
        return function (value1) {
            return new Subscribe(value0, value1);
        };
    };
    return Subscribe;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Unsubscribe = (function () {
    function Unsubscribe(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Unsubscribe.create = function (value0) {
        return function (value1) {
            return new Unsubscribe(value0, value1);
        };
    };
    return Unsubscribe;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Lift = (function () {
    function Lift(value0) {
        this.value0 = value0;
    };
    Lift.create = function (value0) {
        return new Lift(value0);
    };
    return Lift;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Par = (function () {
    function Par(value0) {
        this.value0 = value0;
    };
    Par.create = function (value0) {
        return new Par(value0);
    };
    return Par;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Fork = (function () {
    function Fork(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Fork.create = function (value0) {
        return function (value1) {
            return new Fork(value0, value1);
        };
    };
    return Fork;
})();

// | The Halo evaluation algebra
// |
// | - `props` are the component props
// | - `ctx` is some component context
// | - `state` is the component state
// | - `action` is the set of actions that the component handles
// | - `m` is the monad used during evaluation
// | - `a` is the result type
var Kill = (function () {
    function Kill(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Kill.create = function (value0) {
        return function (value1) {
            return new Kill(value0, value1);
        };
    };
    return Kill;
})();

// | Cancels the event subscription belonging to the `SubscriptionId`.
var unsubscribe = function (sid) {
    return Control_Monad_Free.liftF(new Unsubscribe(sid, Data_Unit.unit));
};

// | Same as `subscribe` but the event-producing logic is also passed the `SuscriptionId`. This is useful when events
// | need to unsubscribe themselves.
var subscribe$prime = function (event) {
    return Control_Monad_Free.liftF(new Subscribe(event, Control_Category.identity(Control_Category.categoryFn)));
};

// | Subscribe to new actions from an `Emitter`. Subscriptions will be automatically cancelled when the component
// | unmounts.
// |
// | Returns a `SubscriptionId` which can be used with `unsubscribe` to manually cancel a subscription.
var subscribe = function ($51) {
    return subscribe$prime(Data_Function["const"]($51));
};
var semigroupHaloM = function (dictSemigroup) {
    return Control_Monad_Free.semigroupFree(dictSemigroup);
};

// | Read the current props.
var props = Control_Monad_Free.liftF(new Props(Control_Category.identity(Control_Category.categoryFn)));
var monoidHaloM = function (dictMonoid) {
    return Control_Monad_Free.monoidFree(dictMonoid);
};
var monadTransHaloM = {
    lift: function (dictMonad) {
        return function ($52) {
            return HaloM(Control_Monad_Free.liftF(Lift.create($52)));
        };
    }
};
var monadHaloM = Control_Monad_Free.freeMonad;
var monadStateHaloM = {
    state: function ($53) {
        return HaloM(Control_Monad_Free.liftF(State.create($53)));
    },
    Monad0: function () {
        return monadHaloM;
    }
};
var monadTellHaloM = function (dictMonadTell) {
    return {
        tell: (function () {
            var $54 = Control_Monad_Trans_Class.lift(monadTransHaloM)(dictMonadTell.Monad1());
            var $55 = Control_Monad_Writer_Class.tell(dictMonadTell);
            return function ($56) {
                return $54($55($56));
            };
        })(),
        Semigroup0: dictMonadTell.Semigroup0,
        Monad1: function () {
            return monadHaloM;
        }
    };
};
var monadThrowHaloM = function (dictMonadThrow) {
    return {
        throwError: (function () {
            var $57 = Control_Monad_Trans_Class.lift(monadTransHaloM)(dictMonadThrow.Monad0());
            var $58 = Control_Monad_Error_Class.throwError(dictMonadThrow);
            return function ($59) {
                return $57($58($59));
            };
        })(),
        Monad0: function () {
            return monadHaloM;
        }
    };
};
var monadEffectHaloM = function (dictMonadEffect) {
    return {
        liftEffect: (function () {
            var $60 = Control_Monad_Trans_Class.lift(monadTransHaloM)(dictMonadEffect.Monad0());
            var $61 = Effect_Class.liftEffect(dictMonadEffect);
            return function ($62) {
                return $60($61($62));
            };
        })(),
        Monad0: function () {
            return monadHaloM;
        }
    };
};
var monadAskHaloM = function (dictMonadAsk) {
    return {
        ask: Control_Monad_Trans_Class.lift(monadTransHaloM)(dictMonadAsk.Monad0())(Control_Monad_Reader_Class.ask(dictMonadAsk)),
        Monad0: function () {
            return monadHaloM;
        }
    };
};
var monadAffHaloM = function (dictMonadAff) {
    return {
        liftAff: (function () {
            var $63 = Control_Monad_Trans_Class.lift(monadTransHaloM)((dictMonadAff.MonadEffect0()).Monad0());
            var $64 = Effect_Aff_Class.liftAff(dictMonadAff);
            return function ($65) {
                return $63($64($65));
            };
        })(),
        MonadEffect0: function () {
            return monadEffectHaloM(dictMonadAff.MonadEffect0());
        }
    };
};

// | Kills the process belonging to the `ForkId`.
var kill = function (fid) {
    return Control_Monad_Free.liftF(new Kill(fid, Data_Unit.unit));
};

// | Hoist (transform) the base applicative of a `HaloAp` expression.
var hoistAp = function (dictFunctor) {
    return function (nat) {
        return function (v) {
            return Control_Applicative_Free.hoistFreeAp(hoist(dictFunctor)(nat))(v);
        };
    };
};

// | Hoist (transform) the base monad of a `HaloM` expression.
var hoist = function (dictFunctor) {
    return function (nat) {
        return function (v) {
            var go = function (v1) {
                if (v1 instanceof Props) {
                    return new Props(v1.value0);
                };
                if (v1 instanceof Context) {
                    return new Context(v1.value0);
                };
                if (v1 instanceof State) {
                    return new State(v1.value0);
                };
                if (v1 instanceof Subscribe) {
                    return new Subscribe(v1.value0, v1.value1);
                };
                if (v1 instanceof Unsubscribe) {
                    return new Unsubscribe(v1.value0, v1.value1);
                };
                if (v1 instanceof Lift) {
                    return new Lift(nat(v1.value0));
                };
                if (v1 instanceof Par) {
                    return new Par(hoistAp(dictFunctor)(nat)(v1.value0));
                };
                if (v1 instanceof Fork) {
                    return new Fork(hoist(dictFunctor)(nat)(v1.value0), v1.value1);
                };
                if (v1 instanceof Kill) {
                    return new Kill(v1.value0, v1.value1);
                };
                throw new Error("Failed pattern match at React.Halo.Internal.Control (line 130, column 8 - line 139, column 29): " + [ v1.constructor.name ]);
            };
            return Control_Monad_Free.hoistFree(go)(v);
        };
    };
};
var functorHaloM = Control_Monad_Free.freeFunctor;
var functorHaloAp = Control_Applicative_Free.functorFreeAp;
var functorHaloF = function (dictFunctor) {
    return {
        map: function (f) {
            return function (v) {
                if (v instanceof Props) {
                    return new Props(function ($66) {
                        return f(v.value0($66));
                    });
                };
                if (v instanceof Context) {
                    return new Context(function ($67) {
                        return f(v.value0($67));
                    });
                };
                if (v instanceof State) {
                    return new State((function () {
                        var $68 = Data_Bifunctor.lmap(Data_Bifunctor.bifunctorTuple)(f);
                        return function ($69) {
                            return $68(v.value0($69));
                        };
                    })());
                };
                if (v instanceof Subscribe) {
                    return new Subscribe(v.value0, Data_Functor.map(Data_Functor.functorFn)(f)(v.value1));
                };
                if (v instanceof Unsubscribe) {
                    return new Unsubscribe(v.value0, f(v.value1));
                };
                if (v instanceof Lift) {
                    return new Lift(Data_Functor.map(dictFunctor)(f)(v.value0));
                };
                if (v instanceof Par) {
                    return new Par(Data_Functor.map(functorHaloAp)(f)(v.value0));
                };
                if (v instanceof Fork) {
                    return new Fork(v.value0, Data_Functor.map(Data_Functor.functorFn)(f)(v.value1));
                };
                if (v instanceof Kill) {
                    return new Kill(v.value0, f(v.value1));
                };
                throw new Error("Failed pattern match at React.Halo.Internal.Control (line 40, column 11 - line 49, column 33): " + [ v.constructor.name ]);
            };
        }
    };
};

// | Start a `HaloM` process running independantly from the current "thread". Forks are tracked automatically and
// | killed when the `Finalize` event occurs (when the component unmounts). New forks can still be created during the
// | `Finalize` event, but once evaluation ends there will be no way of killing them.
// |
// | Returns a `ForkId` for the new process.
var fork = function (m) {
    return Control_Monad_Free.liftF(new Fork(m, Control_Category.identity(Control_Category.categoryFn)));
};

// | Read the current context.
var context = Control_Monad_Free.liftF(new Context(Control_Category.identity(Control_Category.categoryFn)));
var bindHaloM = Control_Monad_Free.freeBind;
var applyHaloM = Control_Monad_Free.freeApply;
var applyHaloAp = Control_Applicative_Free.applyFreeAp;
var applicativeHaloM = Control_Monad_Free.freeApplicative;
var monadRecHaloM = {
    tailRecM: function (k) {
        return function (a) {
            return Control_Bind.bind(bindHaloM)(k(a))(function (v) {
                if (v instanceof Control_Monad_Rec_Class.Loop) {
                    return Control_Monad_Rec_Class.tailRecM(monadRecHaloM)(k)(v.value0);
                };
                if (v instanceof Control_Monad_Rec_Class.Done) {
                    return Control_Applicative.pure(applicativeHaloM)(v.value0);
                };
                throw new Error("Failed pattern match at React.Halo.Internal.Control (line 91, column 11 - line 93, column 27): " + [ v.constructor.name ]);
            });
        };
    },
    Monad0: function () {
        return monadHaloM;
    }
};
var applicativeHaloAp = Control_Applicative_Free.applicativeFreeAp;
var parallelHaloM = {
    parallel: function ($70) {
        return HaloAp(Control_Applicative_Free.liftFreeAp($70));
    },
    sequential: function ($71) {
        return HaloM(Control_Monad_Free.liftF(Par.create($71)));
    },
    Monad0: function () {
        return monadHaloM;
    },
    Applicative1: function () {
        return applicativeHaloAp;
    }
};
module.exports = {
    Props: Props,
    Context: Context,
    State: State,
    Subscribe: Subscribe,
    Unsubscribe: Unsubscribe,
    Lift: Lift,
    Par: Par,
    Fork: Fork,
    Kill: Kill,
    HaloM: HaloM,
    HaloAp: HaloAp,
    hoist: hoist,
    hoistAp: hoistAp,
    props: props,
    context: context,
    subscribe: subscribe,
    "subscribe'": subscribe$prime,
    unsubscribe: unsubscribe,
    fork: fork,
    kill: kill,
    functorHaloF: functorHaloF,
    functorHaloM: functorHaloM,
    applyHaloM: applyHaloM,
    applicativeHaloM: applicativeHaloM,
    bindHaloM: bindHaloM,
    monadHaloM: monadHaloM,
    semigroupHaloM: semigroupHaloM,
    monoidHaloM: monoidHaloM,
    monadTransHaloM: monadTransHaloM,
    monadEffectHaloM: monadEffectHaloM,
    monadAffHaloM: monadAffHaloM,
    monadStateHaloM: monadStateHaloM,
    monadRecHaloM: monadRecHaloM,
    monadAskHaloM: monadAskHaloM,
    monadTellHaloM: monadTellHaloM,
    monadThrowHaloM: monadThrowHaloM,
    functorHaloAp: functorHaloAp,
    applyHaloAp: applyHaloAp,
    applicativeHaloAp: applicativeHaloAp,
    parallelHaloM: parallelHaloM
};
